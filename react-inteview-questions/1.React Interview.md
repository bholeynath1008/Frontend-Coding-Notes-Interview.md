# React Interview Notes - Reorganized

## Table of Contents

### SECTION 1: React Fundamentals
1. [React VS Angular](#1-react-vs-angular)
2. [What is React?](#2-what-is-react)
3. [What is SPA?](#3-what-is-spa)
4. [Features of React](#4-features-of-react)
5. [Problem with Real DOM](#5-problem-with-real-dom)
6. [What is Virtual DOM?](#6-what-is-virtual-dom)
7. [How React/Virtual DOM Works](#7-how-reactvirtual-dom-works)
   - 7.1. [Diffing Algorithm](#71-diffing-algorithm-what-changed)
   - 7.2. [Reconciliation](#72-reconciliation)

### SECTION 2: State Management
8. [State and Props](#8-state-and-props)
9. [Why Direct Mutation is a Problem?](#9-why-direct-mutation-is-a-problem)

### SECTION 3: Components & Props
10. [Stateful and Stateless Component](#10-stateful-and-stateless-component)
11. [Controlled vs Uncontrolled Components](#11-controlled-vs-uncontrolled-components)
12. [Class Based vs Functional Components](#12-class-based-vs-functional-components)
    - 12.1. [Why Functional Components Are Preferred](#121-why-functional-components-are-preferred)
13. [Pure Components in React](#13-pure-components-in-react)
14. [What is react.memo?](#14-what-is-reactmemo)
15. [Lazy Loading](#15-lazy-loading)
16. [Styling in CSS](#16-styling-in-css)
17. [What are Keys?](#17-what-are-keys)
18. [React Strict Mode](#18-react-strict-mode)
19. [Fragment in React and Uses](#19-fragment-in-react-and-uses)

### SECTION 4: Hooks
20. [Rules of Hooks](#20-rules-of-hooks)
21. [Component Lifecycle Phases](#21-component-lifecycle-phases)
22. [React Lifecycle Comparison](#22-react-lifecycle-comparison-class-components-vs-functional-components)
23. [useState Hook](#23-usestate-hook)
24. [useReducer Hook](#24-usereducer-hook)
25. [Context API](#25-context-api)
26. [Ways to Manage State in React](#26-ways-to-manage-state-in-react)
27. [When to use useReducer over useState](#27-when-to-use-usereducer-over-usestate)
28. [useCallback vs useMemo hook](#28-usecallback-vs-usememo-hook)
29. [Custom Hook](#29-custom-hook)
30. [Higher Order Components (HOC)](#30-higher-order-components-hoc)
31. [useEffect Hook](#31-useeffect-hook)
32. [useRef](#32-useref)
33. [Difference between useState and useReducer](#33-difference-between-usestate-and-usereducer)
34. [Redux vs useReducer + Context API](#34-redux-vs-usereducer--context-api)

### SECTION 5: Performance Optimization
35. [How to Improve React Application Performance](#35-how-to-improve-react-application-performance)
36. [Performance Optimization Techniques](#36-performance-optimization-techniques)
37. [React Portal](#37-react-portal)
38. [Error Boundaries](#38-error-boundaries)

### SECTION 6: React 18 Features
39. [Concurrent React - React 18 Interview Cheat Sheet](#39-concurrent-react---react-18-interview-cheat-sheet)
40. [Hooks Mentioned in React 18](#40-hooks-mentioned-in-react-18)
    - A. [useId](#a-useid)
    - B. [useTransition](#b-usetransition)
    - C. [useDeferredValue](#c-usedeferredvalue)
    - D. [useSyncExternalStore](#d-usesyncexternalstore)
    - E. [useInsertionEffect](#e-useinsertioneffect)
41. [Key Features & Concepts](#41-key-features--concepts)
42. [Strict Mode Updates](#42-strict-mode-updates)
43. [Migration Steps (Syntax Change)](#43-migration-steps-syntax-change)
44. [Summary for Interview](#44-summary-for-interview)

### SECTION 7: Testing
45. [React Testing and Its Importance](#45-react-testing-and-its-importance)
46. [What is the purpose of unit testing in React?](#46-what-is-the-purpose-of-unit-testing-in-react)
47. [What are the advantages of using Jest for unit testing?](#47-what-are-the-advantages-of-using-jest-for-unit-testing)
48. [Shallow rendering and full rendering in React testing?](#48-shallow-rendering-and-full-rendering-in-react-testing)
49. [Test asynchronous code in React](#49-test-asynchronous-code-in-react)
50. [What is snapshot testing in React?](#50-what-is-snapshot-testing-in-react)
51. [What to test in React component test?](#51-what-to-test-in-react-component-test)
52. [Component Integration Testing Steps](#52-component-integration-testing-steps)
53. [Steps of Testing using RTL](#53-steps-of-testing-using-rtl)
54. [React Testing Library Queries](#54-react-testing-library-queries)
55. [Mock function in Jest](#55-mock-function-in-jest)
56. [Mock Control Methods](#56-mock-control-methods)
57. [Simulate interactions](#57-simulate-interactions)
58. [Test Lifecycle Methods](#58-test-lifecycle-methods)
59. [Test Component that uses useState](#59-test-component-that-uses-usestate)
60. [Testing Initial Load (API Calls) or useEffect](#60-testing-initial-load-api-calls-or-useeffect)
61. [Testing Dependencies](#61-testing-dependencies)
62. [Why use mock props in React Testing library?](#62-why-use-mock-props-in-react-testing-library)
63. [Why testing with mock data similar to component API call/data?](#63-why-testing-with-mock-data-similar-to-component-api-calldata)
64. [Testing Frameworks](#64-testing-frameworks)

### SECTION 8: React Router
65. [React Router](#65-react-router)
66. [How React Route works?](#66-how-react-route-works)

---

## SECTION 1: React Fundamentals

### 1. React VS Angular

| Aspect | React (Library) | Angular (Framework) |
|--------|----------------|---------------------|
| Type | UI library (you add what you need) | Complete framework (batteries included) |
| Developer | Meta (Facebook) | Google |
| Primary Language | JavaScript + JSX (TypeScript optional & very common) | TypeScript (mandatory) |
| Data Binding | One-way (unidirectional) | Two-way (default) + one-way options |
| DOM Handling | Virtual DOM + reconciliation | Real DOM + change detection (optimized with Ivy) |
| Learning Curve | Easier entry (especially if you know JS) | Steeper (TypeScript, RxJS, DI, modules, decorators) |
| State Management | External (Zustand, Redux, Recoil, Context + useReducer) | Built-in (Services + RxJS) |
| Routing | External (React Router) | Built-in (Angular Router) |
| Forms | External / custom (Formik, React Hook Form) | Built-in powerful forms (template-driven / reactive) |
| Performance | Excellent for dynamic UIs (Virtual DOM + memoization + Server Components in React 19+) | Very good for large apps (AOT compilation, tree-shaking, zoneless in newer versions) |
| Bundle Size | Smaller starting point (add libraries as needed) | Larger out-of-the-box (but optimized well) |
| Tooling / CLI | Create React App / Vite (very fast) | Angular CLI (powerful, but heavier) |

### 2. What is React?

React is an open-source JavaScript library for building user interfaces (UIs), primarily for web applications. It is used to build single page applications and allows you to create reuseable UI components.

### 3. What is SPA?

SPA is a web application that have only one initial webpage/ HTML page (index.html). 
- Loads single HTML page initially. Whenever user do some actions on website (any updates), then response content is dynamically updated without refreshing or loading a new page.  
- After that initial load, all interactions happen dynamically without full page refreshes.

**Why this matters:**
- While there's only one physical HTML file, the application can have many logical "pages" or views (like /home, /profile, /settings) that are handled by JavaScript using the browser's History API.
- The URL changes and it feels like different pages to the user, but no new HTML file is downloaded from the server.

### 4. Features of React

a. **JSX:** Allows writing HTML-like syntax directly in JavaScript code within JavaScript functions.
   - Babel transforms JSX into JavaScript

b. **Components:** Build UI using reusable and independent components, enhancing code maintainability and reusability.

c. **Virtual DOM:** React uses Virtual DOM to minimize direct manipulation of the actual DOM, improving performance through efficient updates.

d. **One Way Data Flow:** Data flows unidirectionally (parent to child), making it easier to track changes and debug applications.

e. **Large Community & Ecosystem:** Extensive ecosystem with abundant tools, libraries, and community support resources available.

### 5. Problem with Real DOM?

a. Even small changes in the application cause the entire layout to re-render
b. For example: Changing just one element (like a title tag) forces the browser to recalculate and re-render the entire DOM tree.
c. This process is very time-consuming and increases page load time. Results in slow performance and poor user experience.

### 6. What is Virtual DOM?

- Virtual DOM is a lightweight representation of the real DOM. It is an in-memory JavaScript object that represents the real DOM structure
- React uses Virtual DOM to efficiently update the user interface without re-rendering the entire page

**Benefits of Virtual DOM:**
- Improved Performance: Updates only the necessary parts instead of the entire page
- Batch Updates: Multiple state updates are batched into a single render cycle
- Better User Experience: Faster updates lead to smoother interactions and enhanced user satisfaction

### 7. How React/Virtual DOM Works

**Step 1:** When we create a React application, it creates a Virtual DOM (lightweight representation of real DOM)

**Step 2:** When changes occur in component state or props, or when something in your app changes. React creates a (2nd) new Virtual DOM with the updated changes. React uses virtual DOM to keep track of what needs to be updated on real DOM. 

**Step 3:** Diffing Algorithm: React now does a "diffing" process. React compares the new Virtual DOM with the previous one to identify what changed

**Step 4:** Reconciliation: Once it knows the specific changes, React goes to the real DOM (the actual webpage) and, in a process called "reconciliation," it only updates those tiny, specific elements that need to change.

**Step 5:** It often batches multiple changes together into a single update cycle. The real DOM is updated with minimal changes in a single render cycle, making React very fast and efficient.

#### 7.1. Diffing Algorithm (What Changed?)

It's the process of comparing the new Virtual DOM tree with the previous one to pinpoint the exact nodes (elements, components) that have changed.
It calculates difference between old and new virtual DOM and determine the minimum set of changes need to update of real dom. 

#### 7.2. Reconciliation

The process where react updates the real DOM by comparing old and new component trees. It priorities important tasks to keep the app responsive.

**React Fiber:** React updated its engine since (React 16) for smoother updates. Its priorities important tasks to keep the app responsive.

```javascript
// Simplified example of priorities:
1. Immediate - Button clicks, text input (needs < 100ms response)
2. High      - Animations, transitions
3. Low       - Data fetching, background calculations
```

**How React Fiber works:**
- Splits work into small chunks (fibers).
- Can pause low-priority tasks (eg. Background loading) to focus on urgent ones (eg. Button click)
- Makes App feel faster, especially for animitaions.

Example: A button click updates instantly while a big list loads in the background

## SECTION 2: State Management

### 8. State and Props

**State:**
- State is a built-in JavaScript object in React that holds data used by components.
- It allows a component to keep track of its data and update it when needed.
- State is mutable - it can be updated using the useState, useReducer Hook and redux state is store.
- In class-based components, state is declared using this.state
- State is used within components to track:
  - User input, API responses, Toggle states, Component-specific data

**Props:**
- Props is a JavaScript object used to pass data from one component to another (parent to child)
- Props are immutable - they are read-only and cannot be modified by the component that receives them
- Props allow components to be reusable and configurable.

### 9. Why Direct Mutation is a Problem?

React relies on the concept of immutability for efficient state management.

When state changes in an immutable way (by creating a copy rather than modifying the existing one), React can easily detect that the state has changed and trigger a re-render of components.

If we mutate state directly (like using array.push() or modifying object properties), React may not recognize that the state has been updated. This happens because the reference to the state object/array hasn't changed - only its internal content was modified.

This can result in a failure to re-render the component, meaning the UI may not reflect the actual state, causing bugs and inconsistencies.

## SECTION 3: Components & Props

### 10. Stateful and Stateless Component

**Stateless Components**
- Components that do not manage or maintain their own state
- They render only the props they receive
- Also called presentational components or dumb components
- Before Hooks, functional components were stateless components

**Stateful Components**
- Components that manage and update their own state
- With the useState Hook, functional components can become stateful
- Class-based components have been stateful in React from the beginning
- Also called smart components or container components

### 11. Controlled vs Uncontrolled Components

**Controlled Components** are components where forms data is handled/ managed by react state. 
- The form field's value is tied to a state variable. Input value = state value, controlled via value prop.
- Changes handled via onChange handler, and update state using onChange handler. 
- Used with interactive elements: text input, radio, checkbox, select dropdown, password, file upload.

**Uncontrolled Components** are components that form data are handled by dom directly, accessed using refs. React doesn't manage values in state. They are faster no-re render required. 

**When to Use:**
- Controlled components: When you need full control over form data, validation, and passing values as props
- Uncontrolled components: When you need direct DOM access/manipulation and don't need state management.

### 12. Class Based vs Functional Components

| Aspect | Class-Based Components | Functional Components |
|--------|----------------------|----------------------|
| Definition | ES6 class extending React.Component | JavaScript function |
| State Management | this.state and this.setState() | useState, useReducer hooks |
| Access Props via | this.props | Function parameters |
| Lifecycle Methods | componentDidMount, componentDidUpdate | useEffect hook |
| Hooks Support | Not supported | Fully supported |
| Code Style | More boilerplate code | Simpler, cleaner syntax |
| State Initialization | Constructor required | Direct with useState |

#### 12.1. Why Functional Components Are Preferred

- Simpler & More Readable: Cleaner code with less boilerplate
- Better State Management: Hooks provide improved state and side effects handling
- No this Binding: Avoids confusion with this keyword
- Easier Testing & Maintenance: Straightforward logic and dependencies
- Modern Standard: React team's recommended approach with full feature support

### 13. Pure Components in React

**Pure Functional Components:**
- It is a component that always renders the same output for the same props and state. When no props and state changes it will give same output. 
- Has no side effects (no API calls, state updates, or DOM manipulations)
- Use React.memo to prevent unnecessary re-renders when props don't change

Example: 
```javascript
const MyComponent = React.memo((props) => { 
  return <div>{props.name}</div>; 
}); 
// Or,
export default memo(MyComponent);
```

**Pure Class Components:**
- Extend React.PureComponent instead of React.Component
- Automatically implements shouldComponentUpdate with shallow prop/state comparison

**Key Benefits:**
- Performance optimization by avoiding unnecessary re-renders
- Predictable behavior with same input = same output

### 14. What is react.memo?

- React.memo is a Higher-Order Component (HOC) that makes functional components pure.
- It Prevents unnecessary re-renders when props remain the same and improves performances.

**How it works:**
- Memorization: Caches the component's rendered output
- Reuses cache if props haven't changed
- Shallow comparison: Compares current vs previous props
  - Primitives (string, number, boolean): It compares values for Primitives data types.
  - Objects/Arrays: It compares references (memory addresses), not content.

**Important Consideration:**
- If passing callback functions as props, use useCallback hook
- Without useCallback, new function references trigger re-renders even with React.memo.

### 15. Lazy Loading

It is a technique used to optimize the performance of application by loading components, images, and other resources when they needed, rather than loading everything upfront. It Improves initial load time and user experience.

**Implementation:**
- Use React's React.lazy() for code-splitting components
- Wrap lazy components with Suspense for fallback UI during loading

**Syntax:**
```javascript
const MyComponent = React.lazy(() => import('./MyComponent'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <MyComponent />
    </Suspense>
  );
}
```

**Use Cases:**
- Route-based splitting (Home, About pages)
- Conditional components (modals, tabs)
- Heavy components with complex logic

**Image Lazy Loading:**
```html
<img src="image.jpg" loading="lazy" alt="description" />
```

**Benefits:**
- Faster initial load
- Better performance
- Efficient resource usage

**How React.lazy() works?**
1. Initial render → Promise pending → shows "Loading..."
   - This returns a Promise that resolves to the component
   ```javascript
   const LazyComponent = React.lazy(() => import('./MyComponent'));
   ```
2. Returns: Promise resolves → component loads → renders actual content
   ```javascript
   // While Promise is pending → shows fallback
   // When Promise resolves → shows actual component
   ```
3. Subsequent renders → uses cached component

### 16. Styling in CSS

**1. Inline CSS**
- Style elements directly with style attribute
- Value must be a JavaScript object
- CSS Stylesheets: Global scope, potential naming conflicts
- Example: `<div style={{ color: 'red', fontSize: '16px' }}>`

**2. CSS Stylesheet**
- Create separate .css file
- Import into component file
- Styles are global by default
- CSS Modules: Local scope, avoids conflicts

**3. CSS Modules**
- File naming: [name].module.css
- Scopes CSS to specific components
- Prevents global naming conflicts
- Classes are locally scoped
- Inline CSS: Component-specific, no external files

### 17. What are Keys?

- Key is a special string attribute used when rendering/ creating lists of elements in React.
- Helps React identify which items have changed, added, or removed

**Problem (Use Index as key):** If we use an index as key and order of item is changed, react may associate the wrong state with wrong items, like if we delete items on row, it will assign index to another item.

**When Keys are Used:**
- When rendering arrays of elements using map(), ie. dynamically generating lists of components
- When list items can be reordered, added, or removed, to track elements in collections/lists
- To optimize the rendering process and improve performance

**Benefits of Keys:**
- To track elements and identify which items are added, modified, or removed
- Allow React to efficiently update only the changed parts of UI and improve performance.

**Problems Without Keys:**
- Unnecessary re-renders of all list items
- Instead of updating only changed items, React re-renders everything when key is not provided.
- Unexpected behavior and state mixing between components
- Slow performance with large lists

### 18. React Strict Mode

- React Strict Mode is a development tool that helps identify potential bugs and issues early in the development process. It does not affect production builds. 
- In development mode, it intentionally invokes certain lifecycle methods and side effects (like useEffect/ API calls) twice to help detect improper handling of side effects and ensure code follows React's best practices.

### 19. Fragment in React and Uses

- It is a way to group multiple elements together without adding an extra node to the DOM. 
- They help avoid unnecessary DOM nodes, keep the DOM structure clean, 
- It prevents unnecessary styling or layout issues of elements.
- For example, using a div (which is a block-level element with default 100% width) as a wrapper can sometimes break CSS layouts or table structures, which fragments solve by providing an invisible wrapper.

## SECTION 4: Hooks

### 20. Rules of Hooks

- Call hooks at the top level of your component - not inside loops, conditions, or nested functions for consistent call order to track.
- Only call hooks from React functional components or custom hooks - not from regular JavaScript functions.
- Custom hooks must start with use prefix (e.g., useLocalStorage), while HOCs (Higher-Order Components) typically start with with (e.g., withAuth)

### 21. Component Lifecycle Phases

1. **Mounting** - Component is being created and inserted into the DOM
   - Constructor → render → componentDidMount (class) / useEffect with empty dependencies (function)

2. **Initialization** - Setting up initial state and props

3. **Updating** - Component re-renders due to state or props changes
   - render → componentDidUpdate (class) / useEffect with dependencies (function)

4. **Unmounting** - Component is being removed from the DOM
   - componentWillUnmount (class) / useEffect cleanup (function)

### 22. React Lifecycle Comparison: Class Components vs. Functional Components

#### 1. Mounting
- **Class Component:** componentDidMount 
- **Functional Component:** useEffect(..., [])
- **Description & When It Runs:** Runs once, after the component is initially rendered and inserted into the DOM.
- **Typical Use Cases:** Fetching data, setting up subscriptions, timers, or performing DOM measurements.

#### 2. Updating
- **Class Component:** componentDidUpdate 
- **Functional Component:** useEffect(..., [dep1, dep2]) 
- **Description & When It Runs:** Runs after every re render caused by changes in props or state (but not on the initial mount). 
- **Typical Use Cases:** Reacting to prop/state changes, performing side effects, or additional DOM updates.

#### 3. Unmounting
- **Class Component:** componentWillUnmount 
- **Functional Component:** Cleanup function returned from useEffect 
- **Description & When It Runs:** Runs once, immediately before the component is removed from the DOM. 
- **Typical Use Cases:** Cleaning up timers, cancelling fetch requests, unsubscribing from subscriptions, or removing event listeners.

#### 4. Render
- **Class Component:** render() method 
- **Functional Component:** Function body (returns JSX) 
- **Description & When It Runs:** Runs every time the component needs to produce or update its output (on mount and every update). 
- **Typical Use Cases:** Describing what should be shown on the screen (pure UI description).

#### Additional Advanced Lifecycle Methods/Hooks

**Pre Render**
- **Class Component:** getDerivedStateFromProps 
- **Functional Component:** (No direct equivalent) 
- **Description & When It Runs:** Runs before render on both mount and update. It returns an object to update the component's state based on props. 
- **Typical Use Cases:** Rarely used; strictly for syncing state with props.

**Update Optimization**
- **Class Component:** shouldComponentUpdate 
- **Functional Component:** React.memo (for components), useMemo, useCallback (for values/functions) 
- **Description & When It Runs:** Runs before render on update. It returns true (re render) or false (skip re render). 
- **Typical Use Cases:** Performance optimization by preventing unnecessary re renders.

**Layout/Sync Effects**
- **Class Component:** (N/A) 
- **Functional Component:** useLayoutEffect 
- **Description & When It Runs:** Identical signature to useEffect, but fires synchronously after all DOM mutations and before the browser paints. 
- **Typical Use Cases:** DOM measurements (like scrolling) or mutations that must be seen before paint.

**Error Handling**
- **Class Component:** componentDidCatch (Class Components Only) 
- **Functional Component:** (Class Components Only) 
- **Description & When It Runs:** Catches JavaScript errors in the child component tree. 
- **Typical Use Cases:** Logging errors and displaying a fallback UI (Error Boundary).

### 23. useState Hook

```javascript
const [state, setState] = useState(initialValue);
```

- **Arguments:** It accepts initial state value as and arguments and, 
- **Returns:** Array with current state, and function to update state. 
- **Why use:** It is used to manages local component-level state.

### 24. useReducer Hook

```javascript
const [state, dispatch] = useReducer(reducer, initialState);
```

**Arguments:** It accepts reducer and initialState as argument and return current state and dispatch. 
- **reducer** – It is a pure function takes current state and an action and return new state.
  - Signature: `(state, action) => newState`
- **initialState** - Initial state value or lazy initializer function initFunction(optional)

**When to use useReducer:**
- Complex state logic
- Large state objects: When state is an object with many properties
- Predictable state management: When you want to centralize state update logic in a reducer function
- It is better to use in certain component tree level to manage states with context API.

**Flow: Dispatch Action → Reducer → New State → Re-render**

1. **Dispatch Action** – When user events/ click events occurs, it triggers state change by calling dispatch ({type: 'ACTION_TYPE', payload: data}) with an action object containing type and optional payload.

2. **Reducer Processes** - Pure function takes current state and action, then returns new state based on action type through switch cases or conditional logic.

3. **State Updates** - React replaces the old state with the new state returned by reducer, ensuring immutable updates

4. **Component Re-renders** - Component and its children automatically re-render with the updated state, reflecting changes in the UI

### 25. Context API

- The context API in react is a way to share data across the component tree without having to pass props manually.
- It avoids prop drilling. No need to pass props manually at multiple component levels/ trees.

**How Context API Works:**
1. Create Context: `const MyContext = createContext();`
2. Provide Context: Wrap components with `<MyContext.Provider value={value}>`
3. Consume Context: `const value = useContext(MyContext);`

### 26. Ways to Manage State in React

**Component-Level State:**
- useState Hook - Local component state

**Global State:**
- Context API - Built-in global state management
- useReducer + Context - Complex global state
- Third-party libraries: Redux, MobX, Recoil, Zustand

### 27. When to use useReducer over useState

- Complex state with multiple properties
- When state updates depend on previous state
- Need predictable and centralized state updates
- Managing large state objects

### 28. useCallback vs useMemo hook

#### useCallback

**Purpose:** Returns a memoized version of the callback function that only changes if one of the dependencies has changed. Passing callbacks to child components (esp. with React.memo). (Return: memorized function)

**Example:** When callback function is passed to child as a props. When child has a large list of tables or expensive calculations it will impact performance of application while continuously re-render. Now that function gets created only once when the parent first mounts. Every re-render after that? Same exact function reference gets passed down. Child sees the prop is same/identical → skips re-rendering. It just does a shallow comparison — basically a quick surface-level check.

Imagine we have got a parent component with a counter or some form input that keeps changing. Every time you type or click, the parent re-renders. Inside that parent, you've defined a simple function like addRow =>{}, And addRow function is passed down as a prop to a child component, the child is a big fancy table or list that shows thousands of rows, maybe with sorting filtering, pagination. That child is wrapped in React.memo so it doesn't re-render unless its props change.

**Why it matters:** In React, every render creates a new function instance if you write onClick={() => ...} or const handleClick = () => .... When you pass this new function to a child component wrapped in React.memo (or memo), the child sees it as a "new prop" → child re-renders even if nothing meaningful changed.

**Signature:**
```javascript
const memoizedCallback = useCallback(() => {
  // your function body
}, [dependency1, dependency2]);   // ← deps array 
```

**Empty Dependencies:** It means with usememo/ useCallback function with empty dependencies it is not dependent on any values from component scope, So, the function will be only created once when component mounts. It stays the same reference, Child doesn't re-render when parent re-renders for unrelated reasons.

#### useMemo

**Purpose:** Memoizes the value/ result of a calculation/function call. It will memorize the result of computation which is based on its props. It runs the function only when dependencies change, otherwise returns the previous cached value. Avoiding re-render by maintaining reference of objects or arrays. (Return: memorized value)

**Why it matters:** Useful when you have expensive computations (filtering large arrays, complex math, creating big objects) that is based with the props, parent state, that you don't want to repeat on every render when props are not changing.

**Example:** When child components depend on parent state and has expensive calculation based on it props coming from parent usememo in the child component to prevent that expensive calculation from being repeated on every render when props are not changed. Preventing new reference → avoids child/child-list re-renders.

The child component gets some props straight from the parent — maybe a big list of users or some data the parent is holding in state. Inside the child, you're doing a heavy calculation based on those props — like filtering thousands of items, sorting them, maybe even doing some math or formatting on each one. Every single time the parent re-renders, the child re-renders too, that same expensive calculation runs all over again, even though the props didn't change at all. That's where it starts feeling slow.

**Signature:**
```javascript
const memoizedValue = useMemo(() => {
  // expensive computation
  return computedResult;
}, [dependency1, dependency2]);
```

### 29. Custom Hook

Custom hooks are JavaScript functions that:
- Start with use (naming convention)
- Can call other React hooks inside them (useState, useEffect, useContext, etc.)
- Let you extract and reuse stateful logic across multiple components without duplicating code.
- **Use Cases:** Data Fetching, Form Handling (useForm), Local Storage, Authentication 

**Benefits of Custom Hooks:**
- **Reusability** — Write logic once, use it in many components. 
- **Abstraction / Cleaner components** — Components focus on UI + what to do, not how to do it → easier to read and maintain. 
- **Better separation of concerns** — Logic lives in one place (the hook), not scattered in components. 
- **Easier testing** — You can test the hook logic independently (using @testing-library/react-hooks or similar), without rendering full components. 
- **Encapsulation** — Hide implementation details (e.g., how fetching works, retry logic, caching, etc.).

**Important Rules & Best Practices:**

1. **Naming:** Must start with use (e.g., useFetch, useAuth).
2. Only call hooks at the top level of the custom hook (no loops, conditions, nested functions).
3. **State management:**
   - Define all related state inside the hook (loading, data, error, etc.).
   - Don't let the component manage hook-related state — pass inputs (like URL, initial value) as arguments.
4. **Inputs & Outputs:**
   - Accept parameters (e.g., URL, options, initial value).
   - Return what the component needs (usually an object or array): { data, loading, error, refetch } or [data, { loading, error }].

### 30. Higher Order Components (HOC)

A Higher-Order Component is an advanced pattern in React (not part of the core API) for reusing component logic.

It is a component/ function that:
- Takes a component as an argument (called the "wrapped" or "base" component)
- Returns a new enhanced component with added props, behavior, state, or rendering logic
- Naming convention: HOCs usually start with with (e.g., withAuth, withTheme, withData)

**Use Case:** Authentication/ Authorization, Theme/ Styling injection, data fetching, loading, Conditional Rendering

```javascript
// Basic structure
function withSomething(WrappedComponent) {
  return function EnhancedComponent(props) {
    // Add logic, props, conditions, etc.
    return <WrappedComponent {...props} extraProp="value" />;
  };
}
// Usage 
const UserProfileWithAuth = withAuth(UserProfile);
```

**Why Use HOCs?**

They solve similar problems to custom hooks — reusing logic across components — but in a different way.

**Main benefits:**
- Reusing logic — e.g., data fetching, authentication checks, logging, conditional rendering
- Adding / injecting props — Pass new data or functions to the wrapped component
- Enhancing behavior — Wrap with loading spinners, error boundaries, permissions, styling, etc.
- Non-invasive — Original component stays unchanged and reusable
- Composition — You can stack multiple HOCs (though it can lead to "wrapper hell")

### 31. useEffect Hook

UseEffect Hooks: A React Hook that allows you to perform side effects in functional components.

- **Side Effects:** Data fetching (API calls), subscriptions, timers, manually changing the DOM, logging. (Subscriptions: like WebSockets, event emitters, or third-party libraries like RxJS)
- **Execution Order:** The component renders first (JSX runs), then useEffect executes after the render is complete.

**Syntax:**

It accepts a callback function (containing the side effect) and a dependency array.

```javascript
useEffect(() => {
  // Side Effect Logic here (e.g., API call)
}, [dependencies]); // Dependency Array
```

#### The Dependency Array (The 4 Cases)

The behavior of the effect depends entirely on what you pass as the second argument.

**Case 1: No Array Provided**

Runs on every single render.

```javascript
useEffect(() => {
  console.log("I run after every render");
});
```

**Case 2: Empty Array []**

Runs only once after the first render (mount).

```javascript
useEffect(() => {
  console.log("I run only once when component mounts");
}, []);
```

**Case 3: Props or State Values [prop, state]**

Runs only when specific values state/prop change.

**Lifecycle Steps:**
1. **First Mount:** Component mounts, renders initial JSX, then executes inside useEffect hooks. (Note: The effect does not create JSX again; the component function creates JSX).
2. **State/Prop Change:** When props change, the component re-runs to create new JSX.
3. **DOM Update:** React compares previous DOM with new JSX and updates the DOM based on the new JSX (diffing).
4. **Effect Execution:** After the DOM update, React executes inside useEffect (if dependencies changed).

```javascript
useEffect(() => {
  console.log("I run when 'count' changes");
}, [count]);
```

**Case 4: Effect Cleanup**

Used for effects that require cleanup (like removing event listeners or clearing timers). The cleanup function runs before the next effect and when the component unmounts.

```javascript
useEffect(() => {
  // Setup (e.g., add event listener)
  const timer = setInterval(() => console.log('tick'), 1000);

  // Cleanup function
  return () => {
    clearInterval(timer); // Cleanup logic
  };
}, []);
```

#### How Cleanup Works

The cleanup function runs in two specific scenarios:
1. **Before Re-render:** If the dependency changes, the previous effect's cleanup runs before the new effect runs.
2. **On Unmount:** When the component is removed from the screen.

**Note:** On the very first render, the cleanup does not run because there is nothing to clean up yet.

**The Lifecycle Flow of useEffect Cleanup:**

1. **First Render (Mount):** Component mounts & renders JSX.
   - useEffect runs (Setup phase).
   - Cleanup: (No Cleanup) — Why? Because there is no previous effect to clean up.

2. **Every Update (Re-render):** Component re-renders (due to prop/state change).
   - Step 1: Cleanup function from Previous render runs.
   - Step 2: useEffect for the New render runs.

3. **Unmount:** Component is about to be removed from the screen.
   - Cleanup function runs (removes listeners/timers).
   - Effect: (No Effect) — Why? Because the component is gone.

#### Dependencies Guide

- **Include:** Props, state, context values, functions, refs, external variables used inside the effect.
- **Avoid (in the array):** Static values or values created/initialized inside the useEffect itself. Including these can cause infinite loops because the reference changes every render.

#### Infinite Loops ⚠️

This happens when the component re-renders, useEffect triggers, updates state, and causes another re-render in an endless cycle.

**Cause 1: Updating State that is a Dependency**

```javascript
// ❌ BAD: Infinite Loop
useEffect(() => {
  setCount(count + 1); // Updates state
}, [count]); // Dependency is that state -> Triggers effect again
```

**Cause 2: Incorrect Dependencies**

Forgetting to list dependencies or listing objects/arrays created inside the render (which change reference on every render). It will cause infinite loops, in each render reference will changed. To prevent indefinite loop: create/ define Global Variables or wrap list with useMemo.

**Cause 3: Unconditional State Updates**

Calling setState directly in the component body (outside of useEffect or event handlers).

```javascript
// ❌ BAD: Runs on every render
function Component() {
  setCount(count + 1); // Causes infinite loop immediately
  return <div>{count}</div>;
}
```

**Cause 4: Misuse of useMemo or useCallback**

If these hooks are not correctly memoizing dependencies passed to useEffect, the effect may re-run unnecessarily.

#### Common useEffect Mistakes

| Mistake | Why it's bad | Fix |
|---------|-------------|-----|
| Missing Dependencies | Linter warnings; effect runs with stale data. | Add all variables used inside effect to the array. |
| Including Objects/Arrays | [ { data: 1 } ] creates a new reference every render, causing infinite loops. | Wrap in useMemo or move outside component. |
| Async Functions | useEffect(() => async () => ...) is not allowed directly. | Define async function inside the effect callback. |
| Cleanup Logic | Forgetting to unsubscribe from events/APIs causes memory leaks. | Always return a cleanup function when needed. |

### 32. useRef

useRef is React hook that is used to persists valuse between/ across component re-renders without triggering re-renders when the value changes. (ref.current = newValue)

**Usage:**

1. **Access Dom Elements directly:** We can use useRef to reference a Dom element directly, This useful when we interact with an elemnent like focusing an input without triggering re-renders.

2. **Persist values between two renders:** useRef can store a mutable value that persists across renders. It updates the .current property of the ref, won't triggers re-render.

**How to use useRef:**

**Step 1: Create Refrence:**

The useRef hook is called to create a reference object of DOM, which has a .current property.

```javascript
const inputRef = useRef(null);      // DOM reference
const timerRef = useRef(null);      // Timer ID storage
const counterRef = useRef(0);       // Value persistence
```

**Step 2: Accessing DOM Elements:**

Use inputRef to get direct access to DOM elements. Attach the ref to a DOM element to get direct access to it.

```javascript
<input ref={inputRef} type="text">
{/* Access stored value */}
<p>Render count: {renderCountRef.current}</p>
```

**Step 3: Persist value between renders:**

Store mutable values that persist across re-renders without triggering re-renders.

```javascript
// Store timer ID (persists across renders)
timerRef.current = setInterval(() => {
  console.log('tick');
}, 1000);

// Count renders (doesn't cause re-render)
renderCountRef.current += 1;
```

**Key Characteristics:**
- **Mutable:** Can modify .current property
- **Persistent:** Value survives re-renders
- **Non-reactive:** Changing .current does NOT trigger re-render

**Use Cases:**
- **DOM Manipulation:** Focus management, Text selection, Media playback control, Animation triggers
- **Persisting Values:** Timer/interval IDs, Previous state/props, Mutable variables, Third-party library instances (like maps)
- **Integration with Libraries:** D3.js, Three.js, ArcGIS, Google Maps Video players, Audio players Charting libraries

### 33. Difference between useState and useReducer

| useState | useReducer |
|----------|------------|
| Manage simple state: number, string, boolean, simple object/array | Manage complex state: object/array with multiple values |
| Directly call the setter function to update (e.g. setCount(count + 1)) | Requires defining actions and reducer function to update states. |
| Logic is handled directly in the component (event handlers) | Logic is centralized in a separate reducer function (pure, predictable) |
| Minimal Boilerplate of code (just declare + setter) | More Boiler plate: define reducer function + action types/objects |
| Passing as props drilling setter can cause unnecessary re-renders in nested trees cause performance issues. | dispatch is stable (never changes), safe to pass down without memoization issues |
| Eg. Toggling a modal, counter, simple form input, theme switch | Eg. Shopping cart (add/remove/update quantities), multi-step form wizard, complex filters/search |

### 34. Redux vs useReducer + Context API

| Redux / Redux Toolkit | useReducer + context API |
|----------------------|--------------------------|
| It is a 3rd-party library for global state management | Built-in React hook |
| Global state management for the entire app | Component level or small tree level state management |
| Supports built in middleware (Redux Thunk, Saga, RTK Query for data fetching) | No built-in middleware — you write your own async logic |
| Integrated with Redux DevTools (time-travel, action replay, state diff) | No built-in devtools |
| More boilerplate with Redux Toolkit (createSlice, createAsyncThunk) | Less boilerplate code — just Context + useReducer |
| Best for very large/frequent updates (with proper selectors + memoization) | Good enough for medium apps; can cause extra renders if not optimized |
| **Use:** Large-scale apps, complex async flows, teams that want strict patterns, need time-travel debugging, heavy data fetching/caching | **Use:** Medium/small apps, theming, auth user, modals, shopping cart in a section, forms spanning a few pages |

## SECTION 5: Performance Optimization

### 35. How to Improve React Application Performance

#### Quick Prioritization for improving performance:

1. **Measure First** → Use React Profiler + Lighthouse + Web Vitals
   - Always start here. Run Lighthouse in Chrome DevTools or PageSpeed Insights
   - Enable React DevTools Profiler tab
   - Add the web-vitals library to production for real-user metrics (CLS, LCP, INP)
   - **Result:** Identifies actual bottlenecks (e.g., render thrashing vs slow network vs large bundle). Don't optimize blindly.

2. **Enable React Compiler + Adopt Server Components** (if using Next.js)
   - React 19's compiler auto-memoizes most things → massive reduction in manual work and re-renders
   - Server Components (RSC) offload rendering to the server → dramatically smaller client bundles (often 30–70% less JS shipped) and no hydration cost for static parts
   - **Result:** Highest impact for modern apps in 2026; enables streaming + partial hydration

3. **Code Splitting + Lazy Loading + Eliminate Waterfalls**
   - Use React.lazy() + Suspense, route-based splitting (Next.js App Router or React Router)
   - Parallelize fetches (e.g., Promise.all)
   - **Result:** Reduces initial bundle by 50%+ in many apps; fixes waterfalls (sequential loading) that kill TTI

4. **Virtualize Lists + Lazy Media**
   - react-window / react-virtualized for long lists/tables
   - loading="lazy" on images + next/image (auto-optimizes format/size)
   - **Result:** Prevents slow scrolling/jank on data-heavy UIs; huge for mobile

5. **Memoization** (Compiler First, Manual as Needed)
   - Rely on React Compiler for automatic useMemo/useCallback/React.memo
   - Use manual hooks only when profiler shows issues (e.g., heavy props drilling or expensive calcs)
   - **Result:** Over-memoizing hurts readability more than it helps in 2026

6. **Bundle Analysis + Tree Shaking + Compression + Minification**
   - **Analyze:** webpack-bundle-analyzer, rollup-plugin-visualizer, or Vite's built-in stats
   - Identify heavy deps (e.g., replace moment → date-fns, lodash → native)
   - **Tree shaking:** Ensure ES modules + "sideEffects": false in package.json where safe
   - Modern bundlers (Vite/Rspack) do this well
   - **Minification:** Automatic in production builds (Terser in Webpack/Vite)
   - **Compression** — This is done on the server/CDN when sending to the browser (frontend):
     - Static assets (JS/CSS from build): Pre-compress during build (e.g., .js.br + .js.gz files) or let CDN/server compress on-the-fly
     - Dynamic responses (SSR HTML, API payloads): Server compresses before sending (e.g., Next.js/Vercel auto-handles)
     - Browser uncompresses automatically on receipt → no manual uncompression needed in frontend code
     - **Best in 2026:** Prefer Brotli (15–25%+ better than Gzip for JS/CSS/HTML text) for static files (widely supported: 97%+ browsers). Use Gzip as fallback for dynamic/edge cases
     - Enable via:
       - Vercel/Netlify/CDN (often default or toggle)
       - Node/Express: compression middleware with Brotli support
       - Nginx/Apache: Configure brotli_static on; or similar
   - **Result:** Reduces transferred size by 60–80% (e.g., 500 KB → 130–150 KB). Huge for slow networks

7. **Debounce/Throttle + Avoid Inline Cruft**
   - Debounce inputs/scrolls (e.g., lodash.debounce or custom hook)
   - Avoid inline styles/functions/objects in JSX (breaks memoization)
   - Prefer CSS modules/Tailwind
   - **Result:** Good for event-heavy UIs but lower overall impact than the above

#### High-Impact Optimizations

1. **Code Splitting & Lazy Loading**
   - Break your app into smaller chunks loaded on demand
   - Use React.lazy() + Suspense for dynamic imports
   - Reduces initial bundle size → faster Time to Interactive (TTI)
   - Essential for routes/heavy components (e.g., charts, modals)

2. **React Compiler** (Automatic Memoization – React 19+)
   - Build-time tool that automatically memoizes components, values, and functions based on data flow analysis
   - Eliminates most need for manual useMemo, useCallback, React.memo
   - Handles cases manual hooks can't (e.g., after early returns, conditionals)
   - Often 20–50% faster renders in production

3. **React.memo for Memoization**
   - Wraps functional components to skip re-renders if props are shallow-equal (unchanged)
   - To make component pure

4. **useCallback & useMemo Hooks**
   - useCallback: Memoizes functions (prevents recreation → stable refs for child props)
   - useMemo: Memoizes expensive computed values
   - Avoid inline functions/objects in JSX (they recreate every render → break memoization)

5. **Virtualize Long Lists**
   - Render only visible items (e.g., infinite scroll feeds, tables with 1000+ rows)
   - Huge impact on scroll performance
   - Libraries: react-window, react-virtualized, or TanStack Table + virtualization

#### Medium-Impact / Supporting Techniques

6. **Lazy Load Media** (Images, etc.)
   - Use loading="lazy" on <img> (native browser support)
   - For advanced: next/image (Next.js) or libraries like react-lazy-load-image-component
   - Reduces initial page weight → better LCP (Largest Contentful Paint)

7. **Debouncing & Throttling**
   - Limit expensive operations (e.g., search input, scroll/resize events)
   - Use lodash.debounce or custom hook
   ```javascript
   const debouncedSearch = useCallback(debounce(handleSearch, 300), []);
   ```

8. **Avoid Inline Styles**
   - Inline styles recalculate on every render (minor hit)
   - Prefer CSS classes/modules or Tailwind for better caching/performance

9. **Bundle Size Optimization**
   - Tree shaking (remove unused code via modern bundlers like Vite/Rspack)
   - Analyze: webpack-bundle-analyzer or rollup-plugin-visualizer
   - Minify JS/CSS, enable Gzip/Brotli compression on server
   - Remove heavy deps (e.g., moment → date-fns)

10. **Use CDN & Asset Optimization**
    - Serve static assets (JS, CSS, images) via CDN → lower latency
    - Modern formats: WebP/AVIF for images, font subsetting
    - Compression: Enable Gzip/Brotli compression for faster transfers

11. **CSS Optimization**
    - Minify CSS
    - Remove unused rules (PurgeCSS / Tailwind's JIT)
    - Combine/compress stylesheets

### 36. Performance Optimization Techniques

1. **List Virtualization (Windowing):**
   - Rendering large lists all at once can harm performance and consume significant memory
   - Virtualization solves this by rendering only a subset of list items currently visible in the viewport
   - As you scroll, it dynamically replaces previous items with new ones (visible items) while maintaining the visible amount
   - Virtualization renders only the visible items in the viewport and recycles DOM elements as the user scrolls
   - This dramatically improves scroll performance and reduces initial render time
   - Library: react-virtualized

2. **Lazy Loading Images:**
   - Instead of loading all images at once, lazy loading defers loading until images are required or about to be displayed in the viewport
   - Typically loads a placeholder, lower-resolution, or smaller-sized thumbnail initially
   - Images are loaded only as the user scrolls the page and they come into view
   - Can be implemented using libraries like React Lazy Load or use native HTML `<img loading="lazy">`

3. **Memoization:** Prevent unnecessary re-renders and expensive calculations
   - **React.memo:** Wrap components to skip re-renders if props are shallow-equal (great for pure components)
   - **useMemo:** Cache computed values (e.g., filtered lists, complex derivations)
   - **useCallback:** Memoize functions to stabilize references (prevents child re-renders when passed as props)
   - **React Compiler** (introduced in React 19), many manual memoizations become automatic—React analyzes and optimizes re-renders for you. Use it first; then fall back to (memo, usememo, usecallback) hooks only where needed

4. **Throttling and Debouncing Events:**
   - High-frequency events (scroll, resize, mousemove, input keystrokes) can trigger excessive function calls
   - Controls function execution to ensure it runs after a set minimum time, managing rapid invocations
   - **Throttling:** A function is repeatedly invoked at specified intervals. Limit calls to once every X ms (great for scroll or resize handlers)
   - **Debouncing:** A function is invoked only after a period of inactivity, useful in scenarios like search input or window resizing. Delay execution until inactivity stops

5. **Code Splitting:**
   - Break your large JavaScript bundle into smaller chunks loaded on demand
   - Use React.lazy() + Suspense for component-level splitting (e.g., routes, modals, heavy features)
   - Tools like webpack/Vite handle route-based or dynamic import splitting automatically
   - Result: Faster initial load, better Time to Interactive (TTI), especially on mobile

6. **React Fragments:**
   - Prevents unnecessary extra DOM elements from rendering
   - Avoid unnecessary wrapper <div> elements when returning multiple children from a component
   - Use <React.Fragment> (or shorthand <>...</>) to group elements without adding extra DOM nodes
   - This reduces DOM depth, slightly improves render speed, and helps with styling/layout (e.g., flex/grid parents)

7. **Web Workers:**
   - Executes multiple tasks in the background, reducing the load on the main thread
   - Handles long-running processes, improving overall performance and responsiveness of the application
   - CPU-intensive tasks (e.g., data parsing, image processing, complex calculations) from the main thread to background Web Workers
   - This prevents UI freezes and keeps the app responsive

8. **Use Transition Hook:**
   - Call useTransition at the top level of your component to mark specific state updates as transitions
   - When multiple state updates occur, React will group them and apply updates efficiently
   - Renders the component once after state updates instead of updating multiple times, enhancing performance
   - Mark non-urgent state updates as "transitions" so React can interrupt them for higher-priority work (e.g., user input)
   - Keeps UI responsive during heavy re-renders (e.g., filtering large lists while typing)
   - Pair with useDeferredValue for deferring values (e.g., search query)
   - In React 19, async actions + transitions handle pending/error/optimistic states automatically

**Profile first** — Use React DevTools Profiler + browser Performance tab to find real bottlenecks before optimizing.

**React Compiler** — Enable it (via babel-plugin-react-compiler) to auto-memoize most cases—reduces manual useMemo/useCallback boilerplate.

### 37. React Portal

React Portals is React methods that provide a way to render HTML outside the parent component's DOM hierarchy, that need to break out of their container's layout.

Useful for components like modals, tooltips, popovers and dialogs.

**How to create React Portals:**

To use a React Portal, you use the createPortal method from react-dom.

1. **children:** The React node (JSX, component, etc.) that you want to render.
2. **domNode:** The target DOM element where the children will be physically placed

First, ensure your index.html (or equivalent file) has a separate mount point for the portal content, for example:

```html
<!-- public/index.html -->
<div id="root"></div>
<div id="modal-root"></div> <!-- The target for our portal -->
</body>
```

### 38. Error Boundaries

Error boundaries are React components that catch JavaScript errors in their child component tree during rendering, in lifecycle methods, and in constructors. They log these errors and display a fallback UI instead of crashing the entire application, which prevents a poor user experience.

**Limitations of Error Boundaries:**

Error boundaries do not catch errors in event handlers, asynchronous code, server-side rendering, or errors within the error boundary component itself. Use try/catch for event handlers and asynchronous operations.

**Why Class based components for Error Boundary?**

Error boundaries in React must be class components because they are the only components that have access to the specific lifecycle methods required to catch errors: static getDerivedStateFromError() and/or componentDidCatch().

- **getDerivedStateFromError(error):** This method is used to update the component's state after an error allowing the component to display a fallback UI (e.g., an error message) instead of the crashed component tree.
- **componentDidCatch(error, info):** This method is used to log error information or perform side effects (like sending error reports)

**Use the Error Boundary:** Wrap components that might throw errors with the Error Boundary.

## SECTION 6: React 18 Features

### 39. Concurrent React - React 18 Interview Cheat Sheet

**Core Focus:** Performance improvements and Concurrent Rendering (a new behind-the-scenes mechanism). 

**Goal:** Prepare for React 18 interviews by understanding the "Why," "How," and the specific Hooks/APIs.

#### 1. The Big Concept: Concurrent Rendering

Think of React as a multitasking assistant now.

**React 18:** March 2022
**Focus:** Performance improvements, updating the rendering engine, and foundation for Concurrent Rendering.

**The Analogy (The Phone Call):**
- **React 17 (Non-Concurrent):** You are calling Alice. You must finish that conversation before you can call Bob. If Alice puts you on hold for 5 minutes, you are frozen for 5 minutes.
- **React 18 (Concurrent):** You are calling Alice. She puts you on hold. React sees you are free, so it pauses the Alice call, lets you quickly call Bob (urgent interaction), finishes with Bob, and then resumes the Alice call.

**What this means for your App:** React can now interrupt, pause, or abandon a render.
- It prioritizes urgent updates (typing, clicking) over heavy background updates (rendering a long list).
- This makes the app feel significantly faster/smoother to the user.

### 40. Hooks Mentioned in React 18

- useId
- useTransition
- useDeferredValue
- useSyncExternalStore
- useInsertionEffect
- Transitions features: startTransition, useTransition

#### A. useId

- **Problem:** In Server-Side Rendering (SSR), generating unique IDs on the server can mismatch (clash) with IDs generated on the client, causing errors.
- **Solution:** useId generates a unique ID that is stable between server and client.
- **Use Case:** Connecting HTML labels to inputs (<label htmlFor={id}>) or for accessibility attributes.

**Code:**
```javascript
const id = useId();
return (
  <div>
    <label htmlFor={id}>Email</label>
    <input id={id} type="text" />
  </div>
);
```

#### B. useTransition

**Concept:** Separating UI updates into two categories (Urgent vs. Non-Urgent)

1. **Urgent:** Direct interactions (typing, clicking, pressing). Need immediate feedback.
2. **Non-Urgent (Transitions):** UI updates that can wait (filtering a large list, rendering a search result).

**Returns:** An array [isPending, startTransition].
- **isPending:** Boolean that is true while the non-urgent update is processing (great for showing a loading spinner).
- **startTransition:** A function used to wrap the slow state update.

**Use Case:** A search filter or a typeahead where typing must be fast, but the list of results can load slightly slower.

**Code:**
```javascript
const [isPending, startTransition] = useTransition();
const [input, setInput] = useState("");
const [list, setList] = useState([]);

const handleChange = (e) => {
  const value = e.target.value;

  // 1. Urgent Update (Typing feels instant)
  setInput(value);

  // 2. Non-Urgent Update (Filtering the list waits)
  startTransition(() => {
    setList(filterBigList(value));
  });
};

return <input value={input} onChange={handleChange} />;
```

#### C. useDeferredValue

**Concept:** A simpler alternative to useTransition. It tells React to "lag" behind a specific value.

**How it works:** You pass it a state (e.g., search text). It returns a "deferred" version of that text that stays one step behind. It only updates the heavy component when the user stops typing.

**Use Case:** Re-rendering a heavy list based on user input.

**Code:**
```javascript
const [text, setText] = useState("");

// deferredText waits until the user pauses typing
const deferredText = useDeferredValue(text);

return (
  <div>
    <input value={text} onChange={(e) => setText(e.target.value)} />
    {/* This heavy list only re-renders for deferredText */}
    <HeavyList data={deferredText} />
  </div>
);
```

#### D. useSyncExternalStore

**Problem:** Third-party stores (like Redux, MobX, or browser APIs) can cause "tearing" in React 18 if they update outside of React's control.

**Solution:** This hook allows external stores to subscribe to React updates safely. It ensures that multiple reads of the store value always return the same data, preventing UI glitches.

**Use Case:** Library authors creating state management libraries or subscribing to window.matchMedia.

#### E. useInsertionEffect

**Problem:** CSS-in-JS libraries (like styled-components) need to inject styles into the DOM before the browser paints the layout.

**Solution:** This hook runs before React modifies the DOM but after React has determined what changes to make.

**Use Case:** Injecting dynamic <style> tags. It is specifically for CSS-in-JS libraries, not typically for application developers.

### 41. Key Features & Concepts

#### Automatic Batching

**In React:**
- **React 17:** Only batched updates inside standard event handlers (e.g., onClick). It did not batch inside fetch, setTimeout, or promises.
- **React 18:** Batches everything (fetches, timeouts, promises).

**Result:** Fewer re-renders → Better performance.

**Opt-out:** If you need code to run immediately after a state update (e.g., measure DOM), use flushSync.

#### Transitions (Urgent vs. Non-Urgent)

- **Urgent:** Direct interactions like typing, clicking, pressing buttons. Users expect immediate feedback.
- **Transitions (Non-Urgent):** UI views like searching a list or rendering a chart. These can wait a few milliseconds without the user noticing.

**Difference from Debounce/setTimeout:**
- setTimeout has a fixed delay (e.g., 500ms).
- startTransition is adaptive. It only waits as long as necessary to keep the UI responsive. If the device is fast, it happens instantly. If the device is slow, it waits.

#### Suspense on the Server (Streaming)

- **Old Way (All or Nothing):** If you rendered a page on the server, you had to load everything (slow components + fast components) before sending a single byte of HTML to the user.
- **React 18 Way (Streaming):** You can wrap a slow component in <Suspense>.
  - The server sends the HTML for the fast parts immediately.
  - It sends a placeholder (loading spinner) for the slow part.
  - When the slow part finishes, the server streams the rest of the HTML.

**Benefit:** The user sees the page skeleton much faster and feels the app is snappier.

### 42. Strict Mode Updates

- **Behavior:** In React 18, Strict Mode simulates unmounting and remounting the component immediately after mount.
- **Why?** To prepare for a future feature where React preserves state (e.g., if you close a tab and come back, the component might resume where you left off).
- **Interview Takeaway:** Ensure your useEffect cleanup functions are robust because they will be invoked twice in development mode.

### 43. Migration Steps (Syntax Change)

To use Concurrent Features, you must update the root API.

**React 17:**
```javascript
import ReactDOM from 'react-dom';
ReactDOM.render(<App />, document.getElementById('root'));
```

**React 18:**
```javascript
import { createRoot } from 'react-dom/client';
const container = document.getElementById('root');
const root = createRoot(container);
root.render(<App />);
```

### 44. Summary for Interview

- React 18 introduces **Concurrent Rendering**, allowing React to interrupt heavy tasks to handle user input first.
- **Automatic Batching** is now enabled for async operations (promises/timeouts).
- **New Hooks:**
  - useId: For unique IDs.
  - useTransition & useDeferredValue: For prioritizing urgent updates over slow ones.
  - useSyncExternalStore: For reading external state safely.
  - useInsertionEffect: For CSS-in-JS libraries.
- **Server Suspense** allows streaming HTML so users see content faster.

## SECTION 7: Testing

### 45. React Testing and Its Importance

React testing is the process of verifying the behavior and functionality of React components and applications. It involves creating and executing automated tests to ensure that the code behaves as expected, and meets the requirements.

**React testing is important for several reasons:**
- It helps identify and prevent defects, bugs, and regressions in the code.
- It helps developers catch issues early in the development cycle, reducing the cost and time required to fix them.
- By having a comprehensive set of tests, developers can confidently make changes to the codebase.

### 46. What is the purpose of unit testing in React?

The purpose of unit testing in React is to test individual units or components of an application in isolation to ensure they work as expected. Unit testing helps to catch errors early in the development process, promotes code quality and maintainability, and provides confidence in the codebase.

### 47. What are the advantages of using Jest for unit testing?

It is easy to use, fast execution speed, built-in mocking capabilities, support for snapshot testing, and integration with other tools like Enzyme.

### 48. Shallow rendering and full rendering in React testing?

Shallow rendering only renders the current component without rendering its child components, while full rendering renders the current component along with all its child components.

### 49. Test asynchronous code in React

Test asynchronous code in React by using asynchronous test functions, mocking asynchronous dependencies, or using the async/await syntax.

### 50. What is snapshot testing in React?

Snapshot testing is a testing technique in which a snapshot of the component's rendered output is saved and compared against future renders to ensure that the component's behavior has not changed unexpectedly.

### 51. What to test in React component test?

1. **Render tests:** Ensure that components render correctly without crashing.
2. **Props handling:** Test if component properly render with props.
3. **User interactions:** Test user actions like click, input change, event handlers working properly.
4. **API Calls:** Ensure API calls work correctly without failing, and behavior when data is empty, undefined, error.
5. **Conditional Component rendering** like in some edge cases like prop is false/true.
6. **Component Integration:** Testing parent child communication. The primary goal is to ensure data flows correctly between components and that they react as expected to each other's state changes or triggered events.

### 52. Component Integration Testing Steps

1. **Render the Parent Component:** The entire component tree is rendered within the test environment.
2. **Simulate User Interaction:** The test code finds the "Submit" button in the parent component and simulates a click event.
3. **Verify Child Component's State:** The test asserts that the child component's content or state has updated to reflect the success message.

### 53. Steps of Testing using RTL

**Simple:**

Define test block using test or it method which will take two arguments first description message, second callback function.

Callback function will test logic:
1. Render the component.
2. Query the DOM using Screen
3. Make assertions using expects.

**Details:**

1. **Import necessary tools:** Import render and screen from @testing-library/react, component, assertion libraries like @testing-library/jest-dom.

2. **Define the test block:** Wrap logic in a test('description', () => { ... }) or it(...). It/test will take two arguments first description message and second callback function.

3. **Render the component:** Use the render(<MyComponent />) function to create a virtual version of your component in the testing environment.

4. **Locate the element (Querying):** Use screen methods to find the element you want to test.
   - Priority 1: getByRole (e.g., button, heading).
   - Priority 2: getByLabelText (for inputs).
   - Priority 3: getByText (for paragraphs or spans).

5. **Simulate user interaction (Optional):** If the test requires a click or typing, use await userEvent.click(element) or await userEvent.type(element, 'text').

6. **Make the assertion:** Use expect(element)... to verify the state. Common assertions include:
   - toBeInTheDocument()
   - toBeVisible()
   - toHaveValue('some text')

7. **Handle Asynchronous updates (Optional):** If you are waiting for an API call or a timer, swap getBy for await screen.findByText(...)

### 54. React Testing Library Queries

In React Testing Library:

**Synchronous queries** (getBy..., queryBy, getByRole, getByTestId) are used for elements present immediately in the DOM:
- getBy* → throws error if element not found
- queryBy* → returns null if element not found (useful for asserting non-existence)

**Asynchronous queries** (findBy..., FindByText, FindByRole, FindByTestId) and the waitFor utility are used to test elements that appear or change after an asynchronous operation.

**waitFor():** wait for condition to meet, to appear in DOM.

**Mistake:** Forgetting await on findBy* queries

### 55. Mock function in Jest

**1. Mocks with jest.fn():**

This is typically used for dependency injection, where you pass the mock as a callback to the function being tested.

- **Usage:** `const myMock = jest.fn();`
- **Implementation:** You can pass a function to provide logic: `jest.fn(x => 42 + x)`.
- **Assertions:** Check calls and arguments using `expect(myMock).toHaveBeenCalledWith(args)`.

**2. Spying on Methods with jest.spyOn()**

Use this to track or replace a method on an existing object or global (like fetch or Math) without destroying the original implementation initially.

- **Usage:** `jest.spyOn(object, 'methodName')`.
- **Mocking Implementation:** After spying, you can override the behavior: `.mockImplementation(() => 'mocked value')`.
- **Restoration:** You can restore the original function later with `.mockRestore()`.

**3. Mocking Modules with jest.mock()**

This is the standard way to handle imported dependencies like axios or local files.

- **Automatic Mocking:** `jest.mock('./myModule')` replaces all exports with mock functions.
- **Module Factories:** Pass a second argument to return a custom object:
```javascript
jest.mock('./myModule', () => ({
  myFunction: jest.fn(() => 'mocked value'),
}));
```
- **Partial Mocking:** Use `jest.requireActual()` inside the factory to mock only specific parts of a module while keeping others intact.

### 56. Mock Control Methods

Once you have a mock, you can control its response dynamically:

- **Static values:** `.mockReturnValue(value)` or `.mockReturnValueOnce(value)`.
- **Promises/Async:** `.mockResolvedValue(value)` or `.mockRejectedValue(error)`.
- **Full Logic:** `.mockImplementation(fn)` for more complex behavior.

To avoid "test pollution," always clean up using `jest.clearAllMocks()` or `jest.restoreAllMocks()` in an afterEach block.

### 57. Simulate interactions

**userEvent (Recommended)**
- **Behavior:** Simulates full interactions rather than single events. For example, userEvent.type() triggers focus, keyDown, keyPress, and keyUp for every character.

**fireEvent**
- **Behavior:** A low-level wrapper around the browser's dispatchEvent API that triggers a single, specific DOM event.

### 58. Test Lifecycle Methods

- **beforeAll:** A function or annotation that runs exactly once before any of the tests in a specific file or block begin.
- **afterAll:** A function or annotation that runs exactly once after all the tests in that file or block have finished.

### 59. Test Component that uses useState

1. Render the component.
2. Find the interactive element (button) and the display element (text).
3. Fire an event (click) to trigger the useState setter.
4. Assert that the DOM updated correctly.

```javascript
// Counter.test.js
import { render, screen, fireEvent } from '@testing-library/react';
import Counter from './Counter';

test('increments count when button is clicked', () => {
  render(<Counter />);
  
  const button = screen.getByText('Increment');
  const display = screen.getByTestId('count-val');

  // Initial state check
  expect(display).toHaveTextContent('0');

  // Trigger state change
  fireEvent.click(button);

  // Assert state updated in the UI
  expect(display).toHaveTextContent('1');
});
```

**Custom Hooks:** If your state logic is complex and reused, extract it into a custom hook and use renderHook from the React Testing Library Hooks to test the logic in isolation.

### 60. Testing Initial Load (API Calls) or useEffect

When useEffect fetches data on mount, use asynchronous queries like findBy to wait for the UI to update.

**Tips:** Mock your APIs data.

```javascript
// Component: Fetches a username on mount
useEffect(() => {
  fetchUser().then(data => setName(data.name));
}, []);

// Test
test('loads and displays name', async () => {
  render(<UserComponent />);
  // findBy queries wait for the element to appear (up to 1000ms by default)
  const nameElement = await screen.findByText(/john doe/i);
  expect(nameElement).toBeInTheDocument();
});
```

### 61. Testing Dependencies

If your effect runs when a prop or state changes, trigger that change in your test (e.g., by clicking a button or re-rendering with new props) and verify the outcome.

- **Action:** Use fireEvent or userEvent to trigger the change.
- **Rerender:** Use the rerender function returned by render to test effect changes based on prop updates.

### 62. Why use mock props in React Testing library?

Mock props in RTL is a common practice, to isolate and test components efficiently.

1. **Isolate component testing:** to make sure its behavior is not influenced by it parent component or external dependency.
2. **Control over Component behavior testing:** By passing mock props we can test different scenarios like empty data, loading states or error conditions.
3. **Faster test Execution:** Mock props eliminates the need of fetch or generate real data, which can slow down tests.
4. **Avoiding side effects:** When testing avoid side effects from external dependencies.
5. **Easy to debug if test case failed.**

### 63. Why testing with mock data similar to component API call/data?

1. To test it with Real API behaviour, to test on actual conditions under which component run.
2. Accurate testing
3. Error testing like real scenarios component behaviour.

### 64. Testing Frameworks

**Jest + RTL:** Traditional React testing setup
**Vitest + RTL:** Modern, faster alternative

#### 1. Jest

**Purpose:** Full-featured JavaScript testing framework (Test framework)

**Key features:**
- Test runner, assertion library, and mocking built-in
- Snapshot testing
- JSDOM for browser environment simulation

```javascript
// Jest example
test('adds 1 + 2 to equal 3', () => {
  expect(1 + 2).toBe(3);
});
```

#### 2. Vitest

**Purpose:** Modern, Vite-native test runner (Test framework)

**Key features:**
- Built on Vite (faster than Jest)
- Same API as Jest (mostly compatible)
- Native ES modules support
- Built-in TypeScript support

```javascript
import { describe, it, expect } from 'vitest';

describe('sum', () => {
  it('adds numbers', () => {
    expect(1 + 2).toBe(3);
  });
});
```

#### 3. React Testing Library (RTL)

**Purpose:** DOM testing utilities for React components (Testing utilities)

**Key features:**
- Encourages testing like a user would interact
- DOM queries (getBy, findBy, queryBy)
- User event simulation

## SECTION 8: React Router

### 65. React Router

React Router is a library for routing in React applications. It enables navigation between different components in react.

### 66. How React Route works?

1. **Browser Router:** `<BrowserRouter>` is the main wrapper component that enables routing. It provides the context for routing and keep track of the history ie. url of application.

2. **Routes:** `<Routes>` component is the container for defining all the routes in your application. `<switch>` was there before react router v6. It ensures first matching `<Route>` is rendered. Switch also do same like render first matching route.

3. **Route:** `<Route>` defines a path and the component to render when the path matches the current URL.
