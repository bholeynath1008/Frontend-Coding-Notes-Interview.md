# React Testing Guide

## Table of Contents

1. [React Testing and Its Importance](#1-react-testing-and-its-importance)
2. [Purpose of Unit Testing in React](#2-purpose-of-unit-testing-in-react)
3. [Advantages of Using Jest for Unit Testing](#3-advantages-of-using-jest-for-unit-testing)
4. [Shallow Rendering and Full Rendering in React Testing](#4-shallow-rendering-and-full-rendering-in-react-testing)
5. [Test Asynchronous Code in React](#5-test-asynchronous-code-in-react)
6. [Snapshot Testing in React](#6-snapshot-testing-in-react)
7. [What to Test in React Component Test](#7-what-to-test-in-react-component-test)
8. [Component Integration Testing Steps](#8-component-integration-testing-steps)
9. [Steps of Testing using RTL](#9-steps-of-testing-using-rtl)
10. [Queries in React Testing Library](#10-queries-in-react-testing-library)
11. [Mock Function in Jest](#11-mock-function-in-jest)
    - Mocks with jest.fn()
    - Spying on Methods with jest.spyOn()
    - Mocking Modules with jest.mock()
12. [Mock Control Methods](#12-mock-control-methods)
13. [Simulate Interactions](#13-simulate-interactions)
    - userEvent (Recommended)
    - fireEvent
14. [Test Lifecycle Hooks](#14-test-lifecycle-hooks)
15. [Test Component that uses useState](#15-test-component-that-uses-usestate)
16. [Testing Initial Load (API Calls) or useEffect](#16-testing-initial-load-api-calls-or-useeffect)
17. [Testing Dependencies](#17-testing-dependencies)
18. [Why Use Mock Props in React Testing Library?](#18-why-use-mock-props-in-react-testing-library)
19. [Why Testing with Mock Data Similar to Component API Call/Data?](#19-why-testing-with-mock-data-similar-to-component-api-calldata)
20. [Jest + RTL vs Vitest + RTL](#20-jest--rtl-vs-vitest--rtl)

---

## 1. React Testing and Its Importance

React testing is the process of verifying the behavior and functionality of React components and applications. It involves creating and executing automated tests to ensure that the code behaves as expected, and meets the requirements.

**React testing is important for several reasons:**
- It helps identify and prevent defects, bugs, and regressions in the code.
- It helps developers catch issues early in the development cycle, reducing the cost and time required to fix them.
- By having a comprehensive set of tests, developers can confidently make changes to the codebase.

## 2. Purpose of Unit Testing in React

The purpose of unit testing in React is to test individual units or components of an application in isolation to ensure they work as expected. Unit testing helps to catch errors early in the development process, promotes code quality and maintainability, and provides confidence in the codebase.

## 3. Advantages of Using Jest for Unit Testing

It is easy to use, fast execution speed, built-in mocking capabilities, support for snapshot testing, and integration with other tools like Enzyme.

## 4. Shallow Rendering and Full Rendering in React Testing

Shallow rendering only renders the current component without rendering its child components, while full rendering renders the current component along with all its child components.

## 5. Test Asynchronous Code in React

Test asynchronous code in React by using asynchronous test functions, mocking asynchronous dependencies, or using the async/await syntax.

## 6. Snapshot Testing in React

Snapshot testing is a testing technique in which a snapshot of the component's rendered output is saved and compared against future renders to ensure that the component's behavior has not changed unexpectedly.

## 7. What to Test in React Component Test

1. **Render tests:** Ensure that components render correctly without crashing.
2. **Props handling:** Test if component properly render with props.
3. **User interactions:** Test user actions like click, input change, event handlers working properly.
4. **API Calls:** Ensure API calls work correctly without failing, and behavior when data is empty, undefined, error.
5. **Conditional Component rendering** like in some edge cases like prop is false/true.
6. **Component Integration:** Testing parent child communication. The primary goal is to ensure data flows correctly between components and that they react as expected to each other's state changes or triggered events.

## 8. Component Integration Testing Steps

1. **Render the Parent Component:** The entire component tree is rendered within the test environment.
2. **Simulate User Interaction:** The test code finds the "Submit" button in the parent component and simulates a click event.
3. **Verify Child Component's State:** The test asserts that the child component's content or state has updated to reflect the success message.

## 9. Steps of Testing using RTL

### Simple:

Define test block using test or it method which will take two arguments first description message, second callback function.

Callback function will test logic:
1. Render the component.
2. Query the DOM using Screen
3. Make assertions using expects.

### Details:

1. **Import necessary tools:** Import render and screen from @testing-library/react, component, assertion libraries like @testing-library/jest-dom.

2. **Define the test block:** Wrap logic in a test('description', () => { ... }) or it(...). It/test will take two arguments first description message and second callback function.

3. **Render the component:** Use the render(<MyComponent />) function to create a virtual version of your component in the testing environment.

4. **Locate the element (Querying):** Use screen methods to find the element you want to test.
   - Priority 1: getByRole (e.g., button, heading).
   - Priority 2: getByLabelText (for inputs).
   - Priority 3: getByText (for paragraphs or spans).

5. **Simulate user interaction (Optional):** If the test requires a click or typing, use await userEvent.click(element) or await userEvent.type(element, 'text').

6. **Make the assertion:** Use expect(element)... to verify the state. Common assertions include:
   - toBeInTheDocument()
   - toBeVisible()
   - toHaveValue('some text')

7. **Handle Asynchronous updates (Optional):** If you are waiting for an API call or a timer, swap getBy for await screen.findByText(...)

## 10. Queries in React Testing Library

In React Testing Library:

**Synchronous queries** (getBy..., queryBy, getByRole, getByTestId) are used for elements present immediately in the DOM:
- getBy* → throws error if element not found
- queryBy* → returns null if element not found (useful for asserting non-existence)

**Asynchronous queries** (findBy..., FindByText, FindByRole, FindByTestId) and the waitFor utility are used to test elements that appear or change after an asynchronous operation.

**waitFor():** wait for condition to meet, to appear in DOM.

**Mistake:** Forgetting await on findBy* queries

## 11. Mock Function in Jest

### Mocks with jest.fn()

This is typically used for dependency injection, where you pass the mock as a callback to the function being tested.

- **Usage:** `const myMock = jest.fn();`
- **Implementation:** You can pass a function to provide logic: `jest.fn(x => 42 + x)`.
- **Assertions:** Check calls and arguments using `expect(myMock).toHaveBeenCalledWith(args)`.

### Spying on Methods with jest.spyOn()

Use this to track or replace a method on an existing object or global (like fetch or Math) without destroying the original implementation initially.

- **Usage:** `jest.spyOn(object, 'methodName')`.
- **Mocking Implementation:** After spying, you can override the behavior: `.mockImplementation(() => 'mocked value')`.
- **Restoration:** You can restore the original function later with `.mockRestore()`.

### Mocking Modules with jest.mock()

This is the standard way to handle imported dependencies like axios or local files.

- **Automatic Mocking:** `jest.mock('./myModule')` replaces all exports with mock functions.
- **Module Factories:** Pass a second argument to return a custom object:
```javascript
jest.mock('./myModule', () => ({
  myFunction: jest.fn(() => 'mocked value'),
}));
```
- **Partial Mocking:** Use `jest.requireActual()` inside the factory to mock only specific parts of a module while keeping others intact.

## 12. Mock Control Methods

Once you have a mock, you can control its response dynamically:

- **Static values:** `.mockReturnValue(value)` or `.mockReturnValueOnce(value)`.
- **Promises/Async:** `.mockResolvedValue(value)` or `.mockRejectedValue(error)`.
- **Full Logic:** `.mockImplementation(fn)` for more complex behavior.

To avoid "test pollution," always clean up using `jest.clearAllMocks()` or `jest.restoreAllMocks()` in an afterEach block.

## 13. Simulate Interactions

### userEvent (Recommended)
- **Behavior:** Simulates full interactions rather than single events. For example, userEvent.type() triggers focus, keyDown, keyPress, and keyUp for every character.

### fireEvent
- **Behavior:** A low-level wrapper around the browser's dispatchEvent API that triggers a single, specific DOM event.

## 14. Test Lifecycle Hooks

- **beforeAll:** A function or annotation that runs exactly once before any of the tests in a specific file or block begin.
- **afterAll:** A function or annotation that runs exactly once after all the tests in that file or block have finished.

## 15. Test Component that uses useState

1. Render the component.
2. Find the interactive element (button) and the display element (text).
3. Fire an event (click) to trigger the useState setter.
4. Assert that the DOM updated correctly.

```javascript
// Counter.test.js
import { render, screen, fireEvent } from '@testing-library/react';
import Counter from './Counter';

test('increments count when button is clicked', () => {
  render(<Counter />);
  
  const button = screen.getByText('Increment');
  const display = screen.getByTestId('count-val');

  // Initial state check
  expect(display).toHaveTextContent('0');

  // Trigger state change
  fireEvent.click(button);

  // Assert state updated in the UI
  expect(display).toHaveTextContent('1');
});
```

**Custom Hooks:** If your state logic is complex and reused, extract it into a custom hook and use renderHook from the React Testing Library Hooks to test the logic in isolation.

## 16. Testing Initial Load (API Calls) or useEffect

When useEffect fetches data on mount, use asynchronous queries like findBy to wait for the UI to update.

**Tips:** Mock your APIs data.

```javascript
// Component: Fetches a username on mount
useEffect(() => {
  fetchUser().then(data => setName(data.name));
}, []);

// Test
test('loads and displays name', async () => {
  render(<UserComponent />);
  // findBy queries wait for the element to appear (up to 1000ms by default)
  const nameElement = await screen.findByText(/john doe/i);
  expect(nameElement).toBeInTheDocument();
});
```

## 17. Testing Dependencies

If your effect runs when a prop or state changes, trigger that change in your test (e.g., by clicking a button or re-rendering with new props) and verify the outcome.

- **Action:** Use fireEvent or userEvent to trigger the change.
- **Rerender:** Use the rerender function returned by render to test effect changes based on prop updates.

## 18. Why Use Mock Props in React Testing Library?

Mock props in RTL is a common practice, to isolate and test components efficiently.

1. **Isolate component testing:** to make sure its behavior is not influenced by it parent component or external dependency.
2. **Control over Component behavior testing:** By passing mock props we can test different scenarios like empty data, loading states or error conditions.
3. **Faster test Execution:** Mock props eliminates the need of fetch or generate real data, which can slow down tests.
4. **Avoiding side effects:** When testing avoid side effects from external dependencies.
5. **Easy to debug if test case failed.**

## 19. Why Testing with Mock Data Similar to Component API Call/Data?

1. To test it with Real API behaviour, to test on actual conditions under which component run.
2. Accurate testing
3. Error testing like real scenarios component behaviour.

## 20. Jest + RTL vs Vitest + RTL

**Jest + RTL:** Traditional React testing setup
**Vitest + RTL:** Modern, faster alternative

### 1. Jest

**Purpose:** Full-featured JavaScript testing framework (Test framework)

**Key features:**
- Test runner, assertion library, and mocking built-in
- Snapshot testing
- JSDOM for browser environment simulation

```javascript
// Jest example
test('adds 1 + 2 to equal 3', () => {
  expect(1 + 2).toBe(3);
});
```

### 2. Vitest

**Purpose:** Modern, Vite-native test runner (Test framework)

**Key features:**
- Built on Vite (faster than Jest)
- Same API as Jest (mostly compatible)
- Native ES modules support
- Built-in TypeScript support

```javascript
import { describe, it, expect } from 'vitest';

describe('sum', () => {
  it('adds numbers', () => {
    expect(1 + 2).toBe(3);
  });
});
```

### 3. React Testing Library (RTL)

**Purpose:** DOM testing utilities for React components (Testing utilities)

**Key features:**
- Encourages testing like a user would interact
- DOM queries (getBy, findBy, queryBy)
- User event simulation
