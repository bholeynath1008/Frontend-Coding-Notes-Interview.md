# React Interview Questions

## Section 3: React Fundamentals

- [1. React vs Angular Comparison](#1-react-vs-angular-comparison)
- [2. What is React?](#2-what-is-react)
- [3. What is SPA?](#3-what-is-spa)
- [4. Features of React](#4-features-of-react)
- [5. Problem with Real DOM](#5-problem-with-real-dom)
- [6. What is Virtual DOM?](#6-what-is-virtual-dom)
- [7. How React/Virtual DOM Works](#7-how-reactvirtual-dom-works)
- [8. How React Rendering Works](#8-how-react-rendering-works)
- [9. Components & Props Patterns](#9-components--props-patterns)
- [10. State and Props](#10-state-and-props)
- [11. Why Direct Mutation is a Problem?](#11-why-direct-mutation-is-a-problem)
- [12. Stateful and Stateless Components](#12-stateful-and-stateless-components)
- [13. Controlled vs Uncontrolled Components](#13-controlled-vs-uncontrolled-components)
- [14. Class-Based vs Functional Components](#14-class-based-vs-functional-components)
- [15. Pure Components in React](#15-pure-components-in-react)
- [16. What is React.memo?](#16-what-is-reactmemo)
- [17. Lazy Loading and Suspense](#17-lazy-loading-and-suspense)
- [18. Styling in CSS](#18-styling-in-css)
- [19. What are Keys?](#19-what-are-keys)
- [20. React Strict Mode](#20-react-strict-mode)
- [21. Fragment in React and Uses](#21-fragment-in-react-and-uses)
## 1. React vs Angular Comparison
Expected Answer: Compare React (library, flexible, JSX) with Angular (framework, opinionated, TypeScript). Hints:
•	React: Library for UI, component-based, virtual DOM, JSX syntax
•	Angular: Full MVC framework, two-way binding, dependency injection, TypeScript
•	React: More flexible, larger ecosystem, steeper learning curve for state management
•	Angular: Batteries included, structured, enterprise-friendly

## 2. What is React?
Expected Answer: React is a JavaScript library for building user interfaces using reusable components. Hints:
•	Declarative: Describe UI for each state, React updates when data changes
•	Component-based: Build encapsulated components managing their own state
•	Learn once, write anywhere: Works on web, mobile (React Native), VR
•	Maintained by Facebook and community

## 3. What is SPA (Single Page Application)?
Expected Answer: Web app that loads single HTML page and updates content dynamically without page reloads. Hints:
•	Initial load downloads HTML, CSS, JS
•	Subsequent navigation happens via JavaScript
•	Better UX: faster transitions, app-like feel
•	Challenges: SEO, initial load time, browser history

## 4. Features of React
Expected Answer: Key features include JSX, Virtual DOM, components, unidirectional data flow, React Native. Hints:
•	JSX: JavaScript + XML syntax, type-safe, compiled to React.createElement()
•	Virtual DOM: In-memory representation, efficient updates via diffing
•	Components: Reusable, composable, manage own state/props
•	Unidirectional data flow: Predictable state changes

## 5. Problem with Real DOM
Expected Answer: Real DOM updates are slow, cause reflows/repaints, inefficient for frequent updates. Hints:
•	Direct DOM manipulation is expensive
•	Each change triggers reflow (layout) and repaint
•	Inefficient for dynamic, complex UIs
•	Manual optimization needed for performance

## 6. What is Virtual DOM?
Expected Answer: Lightweight JavaScript representation of real DOM used for efficient UI updates. Hints:
•	In-memory tree of React elements
•	Diffing algorithm compares virtual trees
•	Batched updates to real DOM
•	Minimizes direct DOM manipulation

## 7. How React/Virtual DOM Works
Expected Answer: React creates virtual DOM, diffs changes, applies minimal updates to real DOM. Hints:
•	Diffing Algorithm: Compares element types, keys, attributes (new and old virtual DOM)
•	Reconciliation: Process of updating DOM to match React elements
•	Keys help identify elements across renders

## 8. How React Rendering Works
React rendering is the process of transforming your components into actual DOM nodes that users can see and interact with. 
Here's how it works: 
1. Component Render Trigger
React triggers a render when:
•	Initial mount: First time loading
•	State changes: useState, useReducer, this.setState
•	Props changes: Parent component re-renders with new props
•	Context changes: Value from Context.Provider changes
•	Hooks changes: useMemo, useCallback dependencies change
2. The Render Phase (Virtual DOM)
Render Phase Steps:
2.1. Call component functions: React calls your component functions
2.2.	Create Virtual DOM tree: Builds a tree of React elements (not real DOM)
2.3.	Diffing algorithm: Compares new Virtual DOM with previous one
2.4.	Reconciliation: Process of updating DOM to match React elements

## 9. Components & Props Patterns
Expected Answer: Design reusable components with proper prop patterns and composition.
•	Controlled vs uncontrolled components
•	React.memo() vs PureComponent
•	Keys for list item identification
•	Fragments for grouping without extra nodes
•	PropTypes or TypeScript for prop validation

## 10. State and Props
Expected Answer: State is internal data that changes, props are external data passed from parent. Hints:
•	State: Managed within component using useState/useReducer
•	Props: Read-only data passed from parent to child
•	Props changes trigger re-render, state changes trigger re-render
•	Lift state up: Share state between components via common ancestor

## 11. Why Direct Mutation is a Problem?
Expected Answer: Direct mutation doesn't trigger re-renders, breaks React's state management. Hints:
•	React uses reference equality for state comparisons
•	Direct mutation: state.items.push(newItem) doesn't create new reference
•	Correct: setItems([...items, newItem]) creates new array
•	Immutable updates ensure predictable rendering

## 12. Stateful and Stateless Components
Expected Answer: Stateful (smart) components manage state, stateless (dumb) components only render props. Hints:
•	Stateful: Class components or functional with hooks, manage data/logic
•	Stateless: Pure functions, receive props, return JSX
•	Container/Presenter pattern: Container manages state, Presenter renders
•	Modern: Hooks blur distinction, all components can have state

## 13. Controlled vs Uncontrolled Components
Expected Answer: Controlled: React manages state; Uncontrolled: DOM manages state via refs. Hints:
•	Controlled: Value prop + onChange handler, single source of truth
•	Uncontrolled: Use ref to access DOM value, form libraries often use
•	Controlled: More React patterns, validation, immediate updates
•	Uncontrolled: Simpler, less code, integrate with non-React code

## 14. Class-Based vs Functional Components
Expected Answer: Class components use ES6 classes, functional components use functions (preferred with hooks). Hints:
•	18.1 Why Functional Components Are Preferred: Simpler, less code, easier testing, hooks
•	Class: Lifecycle methods, this context, more boilerplate
•	Functional: Hooks, no this, easier composition
•	Modern React: Functional components with hooks recommended

## 15. Pure Components in React
Expected Answer: Components that only re-render when props/state change (shallow comparison). Hints:
•	Class: React.PureComponent extends Component with shallow comparison
•	Functional: React.memo() wrapper for functional components
•	Performance optimization, prevent unnecessary re-renders
•	Shallow comparison: compare primitives, object references

## 16. What is React.memo?
Expected Answer: Higher-order component that memoizes functional component based on props. Hints:
•	Wraps component, prevents re-render if props don't change
•	Accepts second arg: custom comparison function
•	Use when: Component renders often with same props, expensive rendering
•	Don't overuse: Memory overhead, premature optimization

## 17. Lazy Loading and Suspense
Expected Answer: Dynamically import components lazily when we need component, don't load every component upfront. to reduce bundle size. Hints:
•	React.lazy() for component-level code splitting
•	Suspense component shows fallback while loading
•	Route-based splitting: Each route loads separately
•	Named exports need default wrapper
Suspense:
Suspense is a powerful tool for managing async operations in React, making your applications feel more responsive and providing better user experience during loading states.

React's Suspense component is primarily used for code splitting and data fetching. Here are its props:
- Fallback (Required): The content to show while children are loading.
- children (Required): The actual content you want to render once it's ready.
- unstable_expectedLoadTime (Experimental, React18+): Tells React how long the loading is expected to take, which helps avoid showing the fallback for very quick loads.
```jsx
<Suspense 
  fallback={<Loading />}
  unstable_expectedLoadTime={5000} // 5 seconds
>
  <HeavyComponent /> // components containing async
</Suspense>
```

## 18. Styling in CSS
Expected Answer: Multiple approaches: CSS Modules, CSS-in-JS, utility classes, styled-components. Hints:
•	CSS Modules: Scoped styles, import styles from './Component.module.css'
•	CSS-in-JS: Styled-components, Emotion, dynamic styles with JavaScript
•	Utility-first: Tailwind CSS, atomic classes
•	Choose based on team preference, project needs

## 19. What are Keys?
Expected Answer: Special string attribute helping React identify which items changed/added/removed. Hints:
•	Required in lists for efficient re-rendering
•	Stable, unique, predictable (not index)
•	Help React match components across renders
•	Wrong keys cause bugs: state mixing, performance issues

## 20. React Strict Mode
Expected Answer: Development tool highlighting potential problems in application. Hints:
•	Wraps app or component tree
•	Detects legacy lifecycle methods, unsafe side effects
•	Double-invokes functions to detect side effects
•	Helps prepare for concurrent features

## 21. Fragment in React and Uses
Expected Answer: Component that lets you group elements without adding extra DOM nodes. Hints:
•	Syntax: <React.Fragment> or <>
•	Useful when returning multiple elements from component
•	Can have key prop when mapping in lists
•	Cleaner DOM structure, no wrapper divs
