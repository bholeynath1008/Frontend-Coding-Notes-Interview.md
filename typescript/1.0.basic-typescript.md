
# TypeScript Notes for Beginners (#frontendc)

## 1. Basic Variables & Type Safety

By default, if you don't define a type, TypeScript treats it as `any` (which means anything goes). However, TypeScript is smart enough to guess the type based on the first value you assign (Type Inference).

### Implicit `any` vs. Strict Typing
```typescript
// ❌ BAD: If we don't write a type, it defaults to 'any'.
let value; 
value = 12;      // Allowed
value = "hello"; // Allowed (TypeScript isn't protecting us here)
```

### Reassignment Rules (`let` vs `const`)
Once TypeScript infers a type, you cannot change it later.

```typescript
// ✅ GOOD: Type is inferred as 'string'
let greeting = "hello"; 
greeting = "hey";      // ✅ Allowed (still a string)
// greeting = 99;      // ❌ ERROR: Cannot assign number to string

// Explicit annotation
let age: number;
age = 18;      
// age = "twenty";     // ❌ ERROR: Cannot assign string to number
```

## 2. Union Types (Multiple Types)
If a variable can hold more than one type, use the pipe `|` operator.

```typescript
// This variable can be a number OR a string
let id: string | number;

id = 66;           // ✅ Allowed
id = "user-001";   // ✅ Allowed
// id = true;       // ❌ ERROR: boolean is not allowed
```

## 3. Arrays

TypeScript arrays are strict. If the array is created with strings, only strings are allowed (unless you explicitly define otherwise).

### Inferred Arrays
```typescript
let names = ["john", "jane", "tom"];
// names.push(3);   // ❌ ERROR: Argument of type 'number' is not assignable to 'string'
names.push("hari"); // ✅ No error
```

### Explicit Array Typing
```typescript
// An array that MUST contain only strings
let shoppingList: string[];
shoppingList = ["milk", "bread"];
// shoppingList = [1, 2, 3]; // ❌ ERROR: Numbers not allowed

// An array that can contain strings OR numbers
let mixedData: (string | number)[];
mixedData = ["name", "age", 44, 100]; // ✅ Allowed
```

## 4. Tuples (New!)
A **Tuple** is a special type of array where:
1.  The **length is fixed**.
2.  The **type of each element is known** (and different) based on its position.

Think of it like a row in a spreadsheet where Column 1 is a String and Column 2 is a Number.

```typescript
// Define a Tuple: [string, number, boolean]
// Position 0 must be string, Position 1 must be number, Position 2 must be boolean
let userDetail: [string, number, boolean];

userDetail = ["Alice", 25, true]; // ✅ Perfect
// userDetail = [25, "Alice", true]; // ❌ ERROR: Order matters!

// Accessing values (normal array access)
console.log(userDetail[0]); // "Alice"
console.log(userDetail[1]); // 25

// A common use case: Database return values (e.g., [id, status])
let dbRow: [number, string] = [101, "active"];
```

## 5. Objects

Objects are strictly typed. You must match the property names and types exactly.

### Inferred Object
```typescript
let user = {
    username: "john",
    age: 22,
    isAdmin: false
};

user.username = "jane"; // ✅ Allowed (string)
// user.username = 33;  // ❌ ERROR: username must be a string
```

### Explicit Object Definition
When you explicitly define the type, **all properties are required** by default.

```typescript
// Define the shape
type UserProfile = {
    username: string;
    age: number;
    isAdmin: boolean;
}

// ❌ ERROR: Missing property 'isAdmin'
let newUser: UserProfile = {
    username: "john",
    age: 23
};
```

### Optional Properties (`?`)
Use the question mark `?` if a property might not exist.

```typescript
type UserProfile = {
    username: string;
    age: number;
    isAdmin: boolean;
    phone?: number; // Optional (might be undefined)
}

// ✅ Allowed (phone is missing)
let validUser: UserProfile = {
    username: "string",
    age: 66,
    isAdmin: false
};

// ✅ Also Allowed (phone is provided)
let userWithPhone: UserProfile = {
    username: "string",
    age: 66,
    isAdmin: false,
    phone: 490123456
};
```

## 6. Functions

You should specify the types for the **Arguments** and the **Return Value**.

### Basic Return Types
```typescript
// Function that returns a string
let sayHi = (): string => {
    return "hello"; 
    // return 5; // ❌ ERROR: Must return string
}
```

### Argument Types & Return Types
```typescript
// Accepts a number, returns a number
let multiply = (num: number): number => {
    return num * 2;
}

// Void: When the function returns nothing
let logMessage = (msg: string): void => {
    console.log(msg);
    // return "hello"; // ❌ ERROR: Cannot return string in void function
}
```

### Optional Arguments (`?`)
Just like in objects, function parameters can be optional.

```typescript
let sum = (num1: number, num2: number, extra?: number) => {
    if (extra) {
        return num1 + num2 + extra;
    }
    return num1 + num2;
}

console.log(sum(2, 3));      // ✅ 5
console.log(sum(2, 3, 10));  // ✅ 15
```

## 7. Types vs. Interfaces

When your object shapes get complex, you can create reusable definitions.
*   **Naming Convention:** Start with a Capital letter (PascalCase).
*   **Syntax:** `type` uses `=`, `interface` uses direct definition.

### Using `type` (Type Alias)
The `type` keyword is very flexible. You can use unions (like `"dark" | "light"`).

```typescript
type UserType = {
    username: string;
    age: number;
    phone?: string;
}

// You can even restrict values (Literal Types)
type Theme = "dark" | "light" | "blue";

type AppSettings = {
    user: UserType;
    theme: Theme; // Can ONLY be "dark", "light", or "blue"
}

const appConfig: AppSettings = {
    user: {
        username: 'john',
        age: 43
    },
    theme: "dark" 
    // theme: "red" // ❌ ERROR: "red" is not allowed
};
```

### Using `interface` (Best for Objects)
Interfaces are similar but specifically designed for **objects**. The biggest advantage is that they can be **extended** (inherited).

```typescript
// Base Interface
interface IUser {
    username: string;
    email: string;
    age: number;
}

// Extending IUser: IEmployee has everything IUser has, plus employeeId
interface IEmployee extends IUser {
    employeeId: number;
    role: "Manager" | "Staff";
}

// ✅ Creating an Employee
const emp: IEmployee = {
    username: "tom",
    email: "tom@company.com",
    age: 55,
    employeeId: 33334,
    role: "Manager"
};

// ❌ ERROR: Missing 'role' property
const badEmp: IEmployee = {
    username: "jerry",
    email: "jerry@company.com",
    age: 20,
    employeeId: 111
};
```

### Summary: `type` vs `interface`
1.  **Use `interface`** if you are defining the shape of an Object, especially if you plan to use inheritance (`extends`).
2.  **Use `type`** if you need to create a Union (e.g., `string | number`) or define a specific list of strings (e.g., `"light" | "dark"`).
