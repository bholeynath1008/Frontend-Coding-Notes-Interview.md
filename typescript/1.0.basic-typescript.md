# üìò TypeScript Master Guide - Index

## **1. Basic Variables & Type Safety**
*   **Implicit vs. Strict Typing:** Understanding `any` and Type Inference.
*   **Reassignment Rules:** Type safety with `let` and `const`.

## **2. Union Types**
*   **Definition:** Handling variables that accept multiple types (e.g., `string | number`).

## **3. Arrays**
*   **Inferred Arrays:** TypeScript's automatic detection of array types.
*   **Explicit Array Typing:** Defining strict types (e.g., `string[]`) and mixed types `(string | number)[]`.

## **4. Tuples**
*   **Definition:** Fixed-length arrays with specific types for each position.
*   **Use Cases:** Database rows and structured data storage.

## **5. Objects**
*   **Inferred Objects:** Type safety in object literals.
*   **Explicit Definitions:** Using `type` for object shapes.
*   **Optional Properties:** Using `?` for non-required fields.

## **6. Enums (Enumerations)**
*   **A. Numeric Enums:** Default behavior and auto-incrementing.
*   **B. String Enums:** Advantages for debugging and API usage.
*   **C. Constant Enums:** Performance benefits (`const enum`).
*   **D. JavaScript Output:** How enums compile and "Reverse Mapping".
*   **‚ö†Ô∏è Common Gotcha:** Safety issues with numeric enums.

## **7. Functions**
*   **Return Types:** Explicitly defining what a function returns.
*   **Argument Types:** Enforcing input types.
*   **Void Type:** Functions that return nothing.
*   **Optional Arguments:** Using `?` in function parameters.

## **8. Types vs. Interfaces**
*   **Using `type` (Type Alias):** Flexibility with Unions and Literal Types.
*   **Using `interface`:** Object shapes and Extension (`extends`).
*   **Summary Comparison:** When to use which.

## **9. Generics (Reusable Components)**
*   **The Problem:** Needing flexibility without losing type safety.
*   **Simple Example:** Basic syntax with ``.
*   **Meaningful Example:** `IApiResponse` for dynamic data payloads.
*   **Advanced Syntax & Scenarios:**
    *   **Syntax 1:** Optional Parameters.
    *   **Syntax 2:** Default Types (``).
    *   **Syntax 3:** Combined Optional + Defaults.
    *   **Syntax 4:** Multiple Generics (`<T, K>`) for independent variables.
*   **Integrated Auth System Example:** Real-world usage of generics for user metadata.
---

## 1. Basic Variables & Type Safety

By default, if you don't define a type, TypeScript treats it as `any` (which means anything goes). However, TypeScript is smart enough to guess the type based on the first value you assign (Type Inference).

### Implicit `any` vs. Strict Typing
```typescript
// ‚ùå BAD: If we don't write a type, it defaults to 'any'.
let value; 
value = 12;      // Allowed
value = "hello"; // Allowed (TypeScript isn't protecting us here)
```

### Reassignment Rules (`let` vs `const`)
Once TypeScript infers a type, you cannot change it later.

```typescript
// ‚úÖ GOOD: Type is inferred as 'string'
let greeting = "hello"; 
greeting = "hey";      // ‚úÖ Allowed (still a string)
// greeting = 99;      // ‚ùå ERROR: Cannot assign number to string

// Explicit annotation
let age: number;
age = 18;      
// age = "twenty";     // ‚ùå ERROR: Cannot assign string to number
```

## 2. Union Types (Multiple Types)
If a variable can hold more than one type, use the pipe `|` operator.

```typescript
// This variable can be a number OR a string
let id: string | number;

id = 66;           // ‚úÖ Allowed
id = "user-001";   // ‚úÖ Allowed
// id = true;       // ‚ùå ERROR: boolean is not allowed
```

## 3. Arrays

TypeScript arrays are strict. If the array is created with strings, only strings are allowed (unless you explicitly define otherwise).

### Inferred Arrays
```typescript
let names = ["john", "jane", "tom"];
// names.push(3);   // ‚ùå ERROR: Argument of type 'number' is not assignable to 'string'
names.push("hari"); // ‚úÖ No error
```

### Explicit Array Typing
```typescript
// An array that MUST contain only strings
let shoppingList: string[];
shoppingList = ["milk", "bread"];
// shoppingList = [1, 2, 3]; // ‚ùå ERROR: Numbers not allowed

// An array that can contain strings OR numbers
let mixedData: (string | number)[];
mixedData = ["name", "age", 44, 100]; // ‚úÖ Allowed
```

## 4. Tuples (New!)
A **Tuple** is a special type of array where:
1.  The **length is fixed**.
2.  The **type of each element is known** (and different) based on its position.

Think of it like a row in a spreadsheet where Column 1 is a String and Column 2 is a Number.

```typescript
// Define a Tuple: [string, number, boolean]
// Position 0 must be string, Position 1 must be number, Position 2 must be boolean
let userDetail: [string, number, boolean];

userDetail = ["Alice", 25, true]; // ‚úÖ Perfect
// userDetail = [25, "Alice", true]; // ‚ùå ERROR: Order matters!

// Accessing values (normal array access)
console.log(userDetail[0]); // "Alice"
console.log(userDetail[1]); // 25

// A common use case: Database return values (e.g., [id, status])
let dbRow: [number, string] = [101, "active"];
```

## 5. Objects

Objects are strictly typed. You must match the property names and types exactly.

### Inferred Object
```typescript
let user = {
    username: "john",
    age: 22,
    isAdmin: false
};

user.username = "jane"; // ‚úÖ Allowed (string)
// user.username = 33;  // ‚ùå ERROR: username must be a string
```

### Explicit Object Definition
When you explicitly define the type, **all properties are required** by default.

```typescript
// Define the shape
type UserProfile = {
    username: string;
    age: number;
    isAdmin: boolean;
}

// ‚ùå ERROR: Missing property 'isAdmin'
let newUser: UserProfile = {
    username: "john",
    age: 23
};
```

### Optional Properties (`?`)
Use the question mark `?` if a property might not exist.

```typescript
type UserProfile = {
    username: string;
    age: number;
    isAdmin: boolean;
    phone?: number; // Optional (might be undefined)
}

// ‚úÖ Allowed (phone is missing)
let validUser: UserProfile = {
    username: "string",
    age: 66,
    isAdmin: false
};

// ‚úÖ Also Allowed (phone is provided)
let userWithPhone: UserProfile = {
    username: "string",
    age: 66,
    isAdmin: false,
    phone: 490123456
};
```

## 6. Enums (Enumerations)
An **`enum`** is a way to define a set of named constants. It makes code more readable by replacing "magic numbers" or strings with descriptive names.

Unlike most TypeScript features, enums generate actual JavaScript code.

### A. Numeric Enums (Default)
By default, enums are number-based. They start at `0` and auto-increment.

```typescript
enum Direction {
  Up,    // 0
  Down,  // 1
  Left,  // 2
  Right  // 3
}

let move: Direction = Direction.Up; // value is 0
```
*   **Custom start:** If you set `Up = 1`, the rest will follow as `2, 3, 4`.

### B. String Enums
These are often preferred because they are easier to debug (you see "SHIPPED" in logs instead of "1").

```typescript
enum OrderStatus {
  Pending = "PENDING",
  Shipped = "SHIPPED",
  Delivered = "DELIVERED"
}

let status: OrderStatus = OrderStatus.Shipped;
```

### C. Constant Enums (`const enum`)
If you want to avoid the extra JavaScript code overhead, use `const enum`. TypeScript inlines the values at compile time.

```typescript
const enum Permissions {
  Read,
  Write,
  Delete
}
```

### D. How Enums Look in JavaScript
Standard numeric enums create a "reverse mapping" object.

```javascript
// Compiled JavaScript
var Direction;
(function (Direction) {
    Direction[Direction["Up"] = 0] = "Up";
    Direction[Direction["Down"] = 1] = "Down";
})(Direction || (Direction = {}));

console.log(Direction.Up); // 0
console.log(Direction[0]); // "Up" (Reverse mapping!)
```

### ‚ö†Ô∏è Common Gotcha
Be careful with numeric enums! TypeScript won't always stop you from assigning a random number that doesn't exist in the enum (e.g., `let dir: Direction = 99`). This is why **String Enums** are often safer.

## 7. Functions

You should specify the types for the **Arguments** and the **Return Value**.

### Basic Return Types
```typescript
// Function that returns a string
let sayHi = (): string => {
    return "hello"; 
    // return 5; // ‚ùå ERROR: Must return string
}
```

### Argument Types & Return Types
```typescript
// Accepts a number, returns a number
let multiply = (num: number): number => {
    return num * 2;
}

// Void: When the function returns nothing
let logMessage = (msg: string): void => {
    console.log(msg);
    // return "hello"; // ‚ùå ERROR: Cannot return string in void function
}
```

### Optional Arguments (`?`)
Just like in objects, function parameters can be optional.

```typescript
let sum = (num1: number, num2: number, extra?: number) => {
    if (extra) {
        return num1 + num2 + extra;
    }
    return num1 + num2;
}

console.log(sum(2, 3));      // ‚úÖ 5
console.log(sum(2, 3, 10));  // ‚úÖ 15
```

## 8. Types vs. Interfaces

When your object shapes get complex, you can create reusable definitions.
*   **Naming Convention:** Start with a Capital letter (PascalCase).
*   **Syntax:** `type` uses `=`, `interface` uses direct definition.

### Using `type` (Type Alias)
The `type` keyword is very flexible. You can use unions (like `"dark" | "light"`).

```typescript
type UserType = {
    username: string;
    age: number;
    phone?: string;
}

// You can even restrict values (Literal Types)
type Theme = "dark" | "light" | "blue";

type AppSettings = {
    user: UserType;
    theme: Theme; // Can ONLY be "dark", "light", or "blue"
}

const appConfig: AppSettings = {
    user: {
        username: 'john',
        age: 43
    },
    theme: "dark" 
    // theme: "red" // ‚ùå ERROR: "red" is not allowed
};
```

### Using `interface` (Best for Objects)
Interfaces are similar but specifically designed for **objects**. The biggest advantage is that they can be **extended** (inherited).

```typescript
// Base Interface
interface IUser {
    username: string;
    email: string;
    age: number;
}

// Extending IUser: IEmployee has everything IUser has, plus employeeId
interface IEmployee extends IUser {
    employeeId: number;
    role: "Manager" | "Staff";
}

// ‚úÖ Creating an Employee
const emp: IEmployee = {
    username: "tom",
    email: "tom@company.com",
    age: 55,
    employeeId: 33334,
    role: "Manager"
};

// ‚ùå ERROR: Missing 'role' property
const badEmp: IEmployee = {
    username: "jerry",
    email: "jerry@company.com",
    age: 20,
    employeeId: 111
};
```

### Summary: `type` vs `interface`
1.  **Use `interface`** if you are defining the shape of an Object, especially if you plan to use inheritance (`extends`).
2.  **Use `type`** if you need to create a Union (e.g., `string | number`) or define a specific list of strings (e.g., `"light" | "dark"`).

## 9. Generics (Reusable Components)
**The Problem:** You want to write a function or interface that works with **ANY** type (string, number, etc.), but keeps type safety.
### Simple Example: 
*Note:* Fore more details see below syntax 1 - 4

```js

// Instead of T, 'Metadata' describes what the generic type represents
// T or Metadata is just a placeholder can be any name for generic type
interface UserAccount<Metadata> {
    username: string;
    details: Metadata[]; // 'details' is more meaningful than 'extra'
}


// Uses a Generic <T> to remain flexible for different detail types.<string, number>

function logUserDetails<T>(account: UserAccount<T>): void {
    console.log(`User: ${account.username}`, account.details);
}

// Case 1. Using it with strings (e.g., User Permissions)
logUserDetails({
    username: "saroj_dev", 
    details: ["admin", "editor"] 
});

// Case 2. Using it with numbers (e.g., Security Access Codes)
logUserDetails({
    username: "saroj_admin", 
    details: [101, 202, 305] 
});

// Case 3. Explicitly passing 'string' as the generic type
logUserDetails<string>({
    username: "saroj_dev", 
    details: ["admin", "editor"] 
});

// Case 4. Explicitly passing 'number' as the generic type
logUserDetails<number>({
    username: "saroj_admin", 
    details: [101, 202, 305] 
});

// Case 5. This allows the array to be mixed
logUserDetails<string | number>({
    username: "saroj_mixed",
    details: ["admin", 101]
});

/* 
Why this works well
Examples 1 & 2: Use Type Inference. TypeScript looks at the data you passed and "guesses" what T is. This makes code cleaner.

Examples 3 & 4: Use Explicit Generics. This is safer because if you tried to put a number inside the details array of example #3, TypeScript would stop you immediately. 
*/
```

### Syntax 1: Optional Parameter Syntax
```typescript
interface UserAccount<Metadata> {
    username: string;
    details?: Metadata[]; // Optional property
}

// The '?' in the parameter makes the whole 'account' object optional
function logUserDetails<T>(account?: UserAccount<T>): void {
    console.log(account?.username, account?.details);
}

```

### The Calls

| Scenario | Code |
| --- | --- |
| **Full Data** | `logUserDetails({ username: "saroj", details: ["admin"] });` |
| **No Details** | `logUserDetails({ username: "saroj" });` |
| **No Argument** | `logUserDetails();` |

---

### Key Breakdown

1. **`details?: Metadata[]`**: You can pass the user object without the `details` key.
2. **`account?: UserAccount<T>`**: You can call the function with no arguments at all.
3. **`account?.username`**: This is **Optional Chaining**. It prevents the code from crashing if `account` is undefined.

### The Syntax 2: Default Type Syntax (for the Generic)
If you want `T `to be `string` by `default` unless you say otherwise:
```js
function logUserDetails<T = string>(account: UserAccount<T>): void {
    console.log(account);
}
```

### Syntax 3:Combined: Optional Parameter with Default Generic
```js
function logUserDetails<T = string>(account?: UserAccount<T>): void {
    if (account) {
        console.log(account);
    }
}
```
### Syntax 4:### The Advanced Generic Syntax (`T` and `K`)

```typescript
interface UserAccount<Metadata> {
    username: string;
    details?: Metadata[]; // Optional property
}

/**
 * @template T - The type for user details (Metadata)
 * @template K - The type for the tracking message or ID
 * @param account - Optional UserAccount object
 * @param logEntry - Optional second parameter of a different type
 */
function logUserDetails<T = string, K = string>(
    account?: UserAccount<T>, 
    logEntry?: K
): void {
    // Optional Chaining: prevents crash if account is undefined
    console.log(`User: ${account?.username ?? "Guest"}`);
    console.log(`Details:`, account?.details);
    
    if (logEntry) {
        console.log(`System Log [${typeof logEntry}]:`, logEntry);
    }
}

```

---

### The Call Scenarios

| Scenario | Code | Note |
| --- | --- | --- |
| **Case 1: Inference** | `logUserDetails({ username: "saroj", details: ["admin"] }, "Sync OK");` | TS infers `T` as `string` and `K` as `string`. |
| **Case 2: Mixed Types** | `logUserDetails({ username: "saroj", details: [101] }, 200);` | TS infers `T` as `number` and `K` as `number`. |
| **Case 3: Explicit** | `logUserDetails<string, number>({ username: "dev" }, 404);` | Explicitly sets `T` to `string` and `K` to `number`. |
| **Case 4: Default** | `logUserDetails({ username: "guest" });` | Uses default `K = string` since no second arg is provided. |
| **Case 5: Empty** | `logUserDetails();` | Valid because `account` is optional (`?`). |

---

### Key Notes on the Implementation

1. **Multiple Placeholders (`<T, K>`)**:
* `T` is locked to the `UserAccount`.
* `K` is a completely independent type for the second argument. This allows you to pass a string message, a numeric error code, or even a complex object without them interfering with each other.


2. **Default Generic Values (`T = string`)**:
* If you don't specify the type and TS can't infer it (like when the function is empty), it defaults to `string`. This prevents the type from defaulting to `any`.


3. **Nullish Coalescing (`??`)**:
* In the `console.log`, we used `account?.username ?? "Guest"`. If `account` is undefined, it cleanly prints "Guest" instead of throwing an error.


4. **Flexible Constraints**:
* By using `<T, K>`, you can now have a `UserAccount` of numbers but a `logEntry` that is a string, which wasn't possible when we only had one generic `T`.


**The Solution:** Generics (``).

### Meaningful Example: Flexible API Response
Imagine an API function that fetches data. Sometimes it fetches a `User`, sometimes a `Product`. The structure is the same (`data` + `success`), but the `data` type changes.

#### Step 1: Define a Generic Interface
```typescript
//  acts as a placeholder for "whatever type we pass later"
interface IApiResponse {
  success: boolean;
  message: string;
  data: T; // The data payload will be of type T
}
```

#### Step 2: Use the Generic Interface
```typescript
// Case A: API returns a User
interface User {
  name: string;
  id: number;
}

const userResponse: IApiResponse<User> = {
  success: true,
  message: "User fetched successfully",
  data: { name: "Saroj", id: 101 } // TypeScript enforces User type here
};

// Case B: API returns a list of Products (String[])
const productResponse: IApiResponse<string[]> = {
  success: true,
  message: "Product list fetched",
  data: ["Laptop", "Mouse"] // TypeScript enforces string[] here
};
```

### Your Integrated Example: Auth System
Here is your requested code, expanded into a meaningful scenario for an **Authentication System** that handles extra metadata (could be permissions, logs, or history).

```typescript
// 1. Define the Generic Interface
//  allows us to specify what type of 'extra' info we are storing
interface IAuth {
  name: string;
  extra: T[] // 'extra' is an array of type T
}

// 2. Define a Generic Function
// This function prints the auth info. It works for ANY type T.
function printAuthInfo(info: IAuth): void {
  console.log(`User: ${info.name}`);
  console.log("Extra Data:", info.extra);
}

// --- USAGE ---

// Scenario A: Admin logs in with String Permissions
const adminAuth: IAuth<string> = {
  name: "Admin_Saroj",
  extra: ["read", "write", "delete"] // T is string
};

printAuthInfo(adminAuth);
// Output: User: Admin_Saroj, Extra Data: ["read", "write", "delete"]


// Scenario B: User logs in with Number IDs (e.g., Group IDs)
const userAuth: IAuth<number> = {
  name: "User_Saroj",
  extra: [101, 102, 554] // T is number
};

printAuthInfo(userAuth);
// Output: User: User_Saroj, Extra Data: [101, 102, 554]
```
