# TypeScript React & Next.js - Essential Patterns

## Table of Contents
1. [Data Fetching & Props](#1-data-fetching--props)
2. [Component Composition (Children)](#2-component-composition-children)
3. [Event Handling](#3-event-handling)
4. [useState Hook](#4-usestate-hook)
5. [useReducer & useContext](#5-usereducer--usecontext)
6. [useRef Hook](#6-useref-hook)
7. [Custom Hooks](#7-custom-hooks)
8. [Generics](#8-generics)
9. [Utility Types (Exclude)](#9-utility-types-exclude)

---

## 1. Data Fetching & Props

### Concept
Fetch data from API → Store in state → Pass to child components via props

### Types Definition
```typescript
// types.ts
export interface Post {
  id: number;
  title: string;
  body: string;
}
```

### React Implementation

**PostList.tsx**
```typescript
import { useState, useEffect } from "react";
import PostCard from "./PostCard";
import { Post } from "./types";

const PostList = () => {
  const [posts, setPosts] = useState<Post[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/posts")
      .then(res => res.json())
      .then(data => {
        setPosts(data.slice(0, 5)); // Get first 5
        setLoading(false);
      })
      .catch(() => setLoading(false));
  }, []);

  if (loading) return <div>Loading...</div>;

  return (
    <div>
      {posts.map(post => (
        <PostCard key={post.id} {...post} />
      ))}
    </div>
  );
};
```

**PostCard.tsx**
```typescript
import { Post } from "./types";

const PostCard = ({ id, title, body }: Post) => {
  return (
    <article style={{
      border: '1px solid #ddd',
      padding: '1rem',
      margin: '1rem 0',
      borderRadius: '4px'
    }}>
      <h3>{title}</h3>
      <p>{body}</p>
    </article>
  );
};

export default PostCard;
```

### Next.js Implementation

**app/posts/page.tsx** (Server Component)
```typescript
import PostCard from "./PostCard";
import { Post } from "./types";

async function getPosts(): Promise<Post[]> {
  const res = await fetch("https://jsonplaceholder.typicode.com/posts");
  return res.json();
}

export default async function PostsPage() {
  const posts = await getPosts();

  return (
    <div>
      <h1>Posts</h1>
      {posts.slice(0, 5).map(post => (
        <PostCard key={post.id} {...post} />
      ))}
    </div>
  );
}
```

**app/posts/PostCard.tsx** (Client Component - if interactive)
```typescript
"use client";

import { Post } from "./types";
import { useState } from "react";

export default function PostCard({ id, title, body }: Post) {
  const [expanded, setExpanded] = useState(false);

  return (
    <article style={{
      border: '1px solid #ddd',
      padding: '1rem',
      margin: '1rem 0',
      borderRadius: '4px'
    }}>
      <h3>{title}</h3>
      <p>{expanded ? body : body.substring(0, 100)}...</p>
      <button onClick={() => setExpanded(!expanded)}>
        {expanded ? 'Less' : 'More'}
      </button>
    </article>
  );
}
```

**Key Points:**
- Props are read-only (immutable)
- Always use `key` prop in lists
- Spread operator `{...post}` passes all properties
- Next.js: Use Server Components for data fetching by default

---

## 2. Component Composition (Children)

### Concept
`children` prop allows nesting components inside other components for reusable layouts.

### React Implementation

**Layout.tsx**
```typescript
import React from "react";

interface LayoutProps {
  children: React.ReactNode;
}

const Layout = ({ children }: LayoutProps) => {
  return (
    <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
      <header style={{ background: '#333', color: 'white', padding: '1rem' }}>
        <h1>My App</h1>
      </header>
      <main style={{ flex: 1, padding: '2rem' }}>
        {children}
      </main>
      <footer style={{ background: '#333', color: 'white', padding: '1rem' }}>
        <p>© 2026 My App</p>
      </footer>
    </div>
  );
};

export default Layout;
```

**App.tsx**
```typescript
import Layout from "./Layout";
import Dashboard from "./Dashboard";

function App() {
  return (
    <Layout>
      <Dashboard />
      <p>Any content here</p>
    </Layout>
  );
}
```

### Next.js Implementation

**app/layout.tsx** (Root Layout)
```typescript
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body style={{ margin: 0, fontFamily: 'system-ui' }}>
        <nav style={{ background: '#333', color: 'white', padding: '1rem' }}>
          <a href="/">Home</a> | <a href="/about">About</a>
        </nav>
        <main style={{ padding: '2rem' }}>
          {children}
        </main>
      </body>
    </html>
  );
}
```

**app/dashboard/layout.tsx** (Nested Layout)
```typescript
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div style={{ display: 'flex', gap: '2rem' }}>
      <aside style={{ width: '200px', background: '#f5f5f5', padding: '1rem' }}>
        <h3>Menu</h3>
        <ul>
          <li>Profile</li>
          <li>Settings</li>
        </ul>
      </aside>
      <div style={{ flex: 1 }}>
        {children}
      </div>
    </div>
  );
}
```

### Common Patterns

**Modal Component**
```typescript
interface ModalProps {
  children: React.ReactNode;
  isOpen: boolean;
  onClose: () => void;
}

const Modal = ({ children, isOpen, onClose }: ModalProps) => {
  if (!isOpen) return null;

  return (
    <div style={{
      position: 'fixed',
      inset: 0,
      background: 'rgba(0,0,0,0.5)',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center'
    }}>
      <div style={{ background: 'white', padding: '2rem', borderRadius: '8px' }}>
        {children}
        <button onClick={onClose}>Close</button>
      </div>
    </div>
  );
};
```

**Card Component**
```typescript
const Card = ({ children }: { children: React.ReactNode }) => (
  <div style={{
    border: '1px solid #ddd',
    borderRadius: '8px',
    padding: '1rem',
    boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
  }}>
    {children}
  </div>
);

// Usage
<Card>
  <h2>Title</h2>
  <p>Content</p>
</Card>
```

**Key Points:**
- Use for layouts, wrappers, and containers
- Next.js automatically uses `layout.tsx` files
- Can nest multiple children-based components

---

## 3. Event Handling

### Concept
React events are typed to ensure type safety when handling user interactions.

### Common Event Types
```typescript
import { ChangeEvent, MouseEvent, FormEvent, KeyboardEvent } from "react";
```

### React Implementation

**Form.tsx**
```typescript
import { useState, ChangeEvent, FormEvent } from "react";

const ContactForm = () => {
  const [email, setEmail] = useState("");
  const [message, setMessage] = useState("");

  const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    console.log({ email, message });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={(e: ChangeEvent<HTMLInputElement>) => setEmail(e.target.value)}
        placeholder="Email"
      />
      <textarea
        value={message}
        onChange={(e: ChangeEvent<HTMLTextAreaElement>) => setMessage(e.target.value)}
        placeholder="Message"
      />
      <button type="submit">Send</button>
    </form>
  );
};
```

### Next.js Implementation

**app/contact/page.tsx**
```typescript
"use client";

import { useState, FormEvent } from "react";

export default function ContactPage() {
  const [formData, setFormData] = useState({ name: "", email: "" });

  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    
    const res = await fetch("/api/contact", {
      method: "POST",
      body: JSON.stringify(formData),
    });
    
    if (res.ok) alert("Sent!");
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        name="name"
        value={formData.name}
        onChange={(e) => setFormData({ ...formData, name: e.target.value })}
      />
      <input
        name="email"
        type="email"
        value={formData.email}
        onChange={(e) => setFormData({ ...formData, email: e.target.value })}
      />
      <button type="submit">Submit</button>
    </form>
  );
}
```

### Event Examples

```typescript
const EventExamples = () => {
  // Button Click
  const handleClick = (e: MouseEvent<HTMLButtonElement>) => {
    console.log("Clicked", e.currentTarget);
  };

  // Input Change
  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    console.log("Value:", e.target.value);
  };

  // Key Press
  const handleKeyPress = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") console.log("Enter pressed");
  };

  return (
    <div>
      <input onChange={handleChange} onKeyPress={handleKeyPress} />
      <button onClick={handleClick}>Click</button>
    </div>
  );
};
```

### Important Rules

**❌ WRONG**
```typescript
<button onClick={handleClick()}>Click</button>  // Calls immediately
```

**✅ CORRECT**
```typescript
<button onClick={handleClick}>Click</button>     // Function reference
<button onClick={() => handleClick()}>Click</button>  // Arrow function
<button onClick={() => deleteItem(id)}>Delete</button>  // With params
```

**Key Points:**
- Always prevent default for form submissions
- Use arrow functions to pass parameters
- TypeScript helps catch event type errors

---

## 4. useState Hook

### Concept
Manages component state that triggers re-renders when updated.

### Syntax
```typescript
const [value, setValue] = useState<Type>(initialValue);
```

### React Examples

**Counter**
```typescript
import { useState } from "react";

const Counter = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
      <button onClick={() => setCount(count - 1)}>-</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
};
```

**Object State**
```typescript
interface User {
  name: string;
  age: number;
}

const UserProfile = () => {
  const [user, setUser] = useState<User | null>(null);

  const createUser = () => {
    setUser({ name: "John", age: 30 });
  };

  const updateAge = () => {
    if (user) {
      setUser({ ...user, age: user.age + 1 });
    }
  };

  return (
    <div>
      {user ? (
        <>
          <p>{user.name}, {user.age}</p>
          <button onClick={updateAge}>Birthday</button>
        </>
      ) : (
        <button onClick={createUser}>Create User</button>
      )}
    </div>
  );
};
```

**Array State**
```typescript
interface Todo {
  id: number;
  text: string;
}

const TodoList = () => {
  const [todos, setTodos] = useState<Todo[]>([]);
  const [input, setInput] = useState("");

  const addTodo = () => {
    setTodos([...todos, { id: Date.now(), text: input }]);
    setInput("");
  };

  const deleteTodo = (id: number) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  return (
    <div>
      <input value={input} onChange={(e) => setInput(e.target.value)} />
      <button onClick={addTodo}>Add</button>
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            {todo.text}
            <button onClick={() => deleteTodo(todo.id)}>X</button>
          </li>
        ))}
      </ul>
    </div>
  );
};
```

### Next.js Examples

**app/counter/page.tsx**
```typescript
"use client";

import { useState } from "react";

export default function CounterPage() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

**Toggle Example**
```typescript
const ToggleComponent = () => {
  const [isVisible, setIsVisible] = useState(false);

  return (
    <div>
      <button onClick={() => setIsVisible(!isVisible)}>
        {isVisible ? "Hide" : "Show"}
      </button>
      {isVisible && <p>Hidden content!</p>}
    </div>
  );
};
```

**Key Points:**
- State updates trigger re-renders
- Always use spread operator for objects/arrays
- Can be null initially: `useState<Type | null>(null)`
- Functional updates for previous state: `setCount(prev => prev + 1)`

---

## 5. useReducer & useContext

### Concept
- **useReducer**: Manage complex state with actions (like Redux)
- **useContext**: Share state across components without prop drilling

### Types
```typescript
// types.ts
export type State = {
  theme: "light" | "dark";
  fontSize: number;
};

export type Action =
  | { type: "TOGGLE_THEME" }
  | { type: "SET_FONTSIZE"; payload: number };
```

### React Implementation

**ThemeContext.tsx**
```typescript
import { createContext, useReducer, useContext } from "react";
import { State, Action } from "./types";

const initialState: State = {
  theme: "dark",
  fontSize: 16,
};

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "TOGGLE_THEME":
      return { ...state, theme: state.theme === "dark" ? "light" : "dark" };
    case "SET_FONTSIZE":
      return { ...state, fontSize: action.payload };
    default:
      return state;
  }
};

const ThemeContext = createContext<{
  state: State;
  dispatch: React.Dispatch<Action>;
} | null>(null);

export const ThemeProvider = ({ children }: { children: React.ReactNode }) => {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <ThemeContext.Provider value={{ state, dispatch }}>
      {children}
    </ThemeContext.Provider>
  );
};

// Custom hook for easier usage
export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) throw new Error("useTheme must be used within ThemeProvider");
  return context;
};
```

**App.tsx**
```typescript
import { ThemeProvider } from "./ThemeContext";
import ThemeControls from "./ThemeControls";
import Content from "./Content";

function App() {
  return (
    <ThemeProvider>
      <ThemeControls />
      <Content />
    </ThemeProvider>
  );
}
```

**ThemeControls.tsx**
```typescript
import { useTheme } from "./ThemeContext";

const ThemeControls = () => {
  const { state, dispatch } = useTheme();

  return (
    <div>
      <button onClick={() => dispatch({ type: "TOGGLE_THEME" })}>
        Toggle Theme
      </button>
      <button onClick={() => dispatch({ type: "SET_FONTSIZE", payload: 14 })}>
        Small
      </button>
      <button onClick={() => dispatch({ type: "SET_FONTSIZE", payload: 20 })}>
        Large
      </button>
      <p>Theme: {state.theme} | Size: {state.fontSize}px</p>
    </div>
  );
};

export default ThemeControls;
```

**Content.tsx**
```typescript
import { useTheme } from "./ThemeContext";

const Content = () => {
  const { state } = useTheme();

  return (
    <div
      style={{
        background: state.theme === "dark" ? "#333" : "#fff",
        color: state.theme === "dark" ? "#fff" : "#333",
        fontSize: `${state.fontSize}px`,
        padding: "2rem",
      }}
    >
      <p>This content adapts to theme settings</p>
    </div>
  );
};

export default Content;
```

### Next.js Implementation

**app/providers.tsx**
```typescript
"use client";

import { ThemeProvider } from "./ThemeContext";

export function Providers({ children }: { children: React.ReactNode }) {
  return <ThemeProvider>{children}</ThemeProvider>;
}
```

**app/layout.tsx**
```typescript
import { Providers } from "./providers";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
```

### Simple Todo Example

```typescript
type TodoState = { id: number; text: string; done: boolean }[];
type TodoAction =
  | { type: "ADD"; text: string }
  | { type: "TOGGLE"; id: number }
  | { type: "DELETE"; id: number };

const todoReducer = (state: TodoState, action: TodoAction): TodoState => {
  switch (action.type) {
    case "ADD":
      return [...state, { id: Date.now(), text: action.text, done: false }];
    case "TOGGLE":
      return state.map(todo =>
        todo.id === action.id ? { ...todo, done: !todo.done } : todo
      );
    case "DELETE":
      return state.filter(todo => todo.id !== action.id);
    default:
      return state;
  }
};

const TodoApp = () => {
  const [todos, dispatch] = useReducer(todoReducer, []);
  const [input, setInput] = useState("");

  return (
    <div>
      <input value={input} onChange={(e) => setInput(e.target.value)} />
      <button onClick={() => { dispatch({ type: "ADD", text: input }); setInput(""); }}>
        Add
      </button>
      {todos.map(todo => (
        <div key={todo.id}>
          <input
            type="checkbox"
            checked={todo.done}
            onChange={() => dispatch({ type: "TOGGLE", id: todo.id })}
          />
          <span style={{ textDecoration: todo.done ? "line-through" : "none" }}>
            {todo.text}
          </span>
          <button onClick={() => dispatch({ type: "DELETE", id: todo.id })}>X</button>
        </div>
      ))}
    </div>
  );
};
```

**Key Points:**
- Use `useReducer` for complex state logic
- Use `useContext` to avoid prop drilling
- Combine both for global state management
- Create custom hooks for easier context consumption

---

## 6. useRef Hook

### Concept
Access DOM elements directly or store mutable values without causing re-renders.

### Use Cases
- Focus inputs
- Store timer IDs
- Access DOM elements
- Store previous values

### React Implementation

**Focus Input**
```typescript
import { useRef } from "react";

const FocusInput = () => {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleFocus = () => {
    inputRef.current?.focus();
  };

  return (
    <div>
      <input ref={inputRef} placeholder="Click button to focus" />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
};
```

**Timer Example**
```typescript
import { useState, useRef } from "react";

const Timer = () => {
  const [seconds, setSeconds] = useState(0);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const start = () => {
    if (intervalRef.current) return;
    intervalRef.current = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);
  };

  const stop = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };

  return (
    <div>
      <p>{seconds}s</p>
      <button onClick={start}>Start</button>
      <button onClick={stop}>Stop</button>
      <button onClick={() => { stop(); setSeconds(0); }}>Reset</button>
    </div>
  );
};
```

**Previous Value**
```typescript
import { useState, useRef, useEffect } from "react";

const PreviousValue = () => {
  const [count, setCount] = useState(0);
  const prevCountRef = useRef<number>();

  useEffect(() => {
    prevCountRef.current = count;
  }, [count]);

  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCountRef.current}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
};
```

### Next.js Implementation

**app/focus/page.tsx**
```typescript
"use client";

import { useRef, useEffect } from "react";

export default function FocusPage() {
  const inputRef = useRef<HTMLInputElement>(null);
  const usernameRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    inputRef.current?.focus(); // Auto-focus on mount
  }, []);

  const handleSubmit = () => {
    console.log("Email:", inputRef.current?.value);
    console.log("Username:", usernameRef.current?.value);
  };

  return (
    <div>
      <input ref={inputRef} placeholder="Auto-focused" />
      <input ref={usernameRef} placeholder="Username" />
      <button onClick={handleSubmit}>Submit</button>
    </div>
  );
}
```

**Video Player Control**
```typescript
"use client";

import { useRef } from "react";

export default function VideoPlayer() {
  const videoRef = useRef<HTMLVideoElement>(null);

  return (
    <div>
      <video ref={videoRef} width="400">
        <source src="/video.mp4" type="video/mp4" />
      </video>
      <button onClick={() => videoRef.current?.play()}>Play</button>
      <button onClick={() => videoRef.current?.pause()}>Pause</button>
    </div>
  );
}
```

### useRef vs useState

```typescript
const Example = () => {
  const [stateValue, setStateValue] = useState(0);
  const refValue = useRef(0);

  const incrementState = () => {
    setStateValue(stateValue + 1); // Causes re-render
  };

  const incrementRef = () => {
    refValue.current += 1; // No re-render
    console.log("Ref:", refValue.current);
  };

  return (
    <div>
      <p>State (re-renders): {stateValue}</p>
      <p>Ref (no re-render): {refValue.current}</p>
      <button onClick={incrementState}>Update State</button>
      <button onClick={incrementRef}>Update Ref</button>
    </div>
  );
};
```

**Key Points:**
- `useRef` doesn't trigger re-renders
- Use for DOM access and persistent values
- `.current` property holds the value
- Ideal for timers, intervals, and previous values

---

## 7. Custom Hooks

### Concept
Custom hooks are reusable functions that use React hooks internally. They must start with "use".

### Benefits
- Reuse stateful logic across components
- Keep components clean
- Share logic without prop drilling

### React Implementation

**useFetch Hook**
```typescript
// hooks/useFetch.ts
import { useState, useEffect } from "react";

interface FetchState<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
}

export function useFetch<T>(url: string): FetchState<T> {
  const [state, setState] = useState<FetchState<T>>({
    data: null,
    loading: true,
    error: null,
  });

  useEffect(() => {
    const fetchData = async () => {
      try {
        const res = await fetch(url);
        const data = await res.json();
        setState({ data, loading: false, error: null });
      } catch (error) {
        setState({ data: null, loading: false, error: "Failed to fetch" });
      }
    };

    fetchData();
  }, [url]);

  return state;
}

// Usage
interface User {
  id: number;
  name: string;
}

const UserList = () => {
  const { data, loading, error } = useFetch<User[]>(
    "https://jsonplaceholder.typicode.com/users"
  );

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;

  return (
    <ul>
      {data?.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
};
```

**useLocalStorage Hook**
```typescript
// hooks/useLocalStorage.ts
import { useState, useEffect } from "react";

export function useLocalStorage<T>(key: string, initialValue: T) {
  const [value, setValue] = useState<T>(() => {
    const item = window.localStorage.getItem(key);
    return item ? JSON.parse(item) : initialValue;
  });

  useEffect(() => {
    window.localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue] as const;
}

// Usage
const Settings = () => {
  const [theme, setTheme] = useLocalStorage<"light" | "dark">("theme", "dark");

  return (
    <div>
      <p>Theme: {theme}</p>
      <button onClick={() => setTheme(theme === "dark" ? "light" : "dark")}>
        Toggle Theme
      </button>
    </div>
  );
};
```

**useToggle Hook**
```typescript
// hooks/useToggle.ts
import { useState } from "react";

export function useToggle(initialValue: boolean = false) {
  const [value, setValue] = useState(initialValue);

  const toggle = () => setValue(v => !v);
  const setTrue = () => setValue(true);
  const setFalse = () => setValue(false);

  return { value, toggle, setTrue, setFalse };
}

// Usage
const Modal = () => {
  const { value: isOpen, toggle, setTrue, setFalse } = useToggle();

  return (
    <div>
      <button onClick={setTrue}>Open Modal</button>
      {isOpen && (
        <div>
          <p>Modal Content</p>
          <button onClick={setFalse}>Close</button>
        </div>
      )}
    </div>
  );
};
```

**useDebounce Hook**
```typescript
// hooks/useDebounce.ts
import { useState, useEffect } from "react";

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(handler);
  }, [value, delay]);

  return debouncedValue;
}

// Usage
const SearchComponent = () => {
  const [search, setSearch] = useState("");
  const debouncedSearch = useDebounce(search, 500);

  useEffect(() => {
    if (debouncedSearch) {
      console.log("Searching for:", debouncedSearch);
      // Perform search
    }
  }, [debouncedSearch]);

  return (
    <input
      value={search}
      onChange={(e) => setSearch(e.target.value)}
      placeholder="Search..."
    />
  );
};
```

**useForm Hook**
```typescript
// hooks/useForm.ts
import { useState, ChangeEvent } from "react";

export function useForm<T extends Record<string, any>>(initialValues: T) {
  const [values, setValues] = useState<T>(initialValues);

  const handleChange = (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setValues(prev => ({ ...prev, [name]: value }));
  };

  const reset = () => setValues(initialValues);

  return { values, handleChange, reset, setValues };
}

// Usage
interface LoginForm {
  email: string;
  password: string;
}

const LoginForm = () => {
  const { values, handleChange, reset } = useForm<LoginForm>({
    email: "",
    password: "",
  });

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    console.log(values);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input name="email" value={values.email} onChange={handleChange} />
      <input name="password" type="password" value={values.password} onChange={handleChange} />
      <button type="submit">Login</button>
      <button type="button" onClick={reset}>Reset</button>
    </form>
  );
};
```

### Next.js Implementation

**useMediaQuery Hook**
```typescript
// hooks/useMediaQuery.ts
"use client";

import { useState, useEffect } from "react";

export function useMediaQuery(query: string): boolean {
  const [matches, setMatches] = useState(false);

  useEffect(() => {
    const media = window.matchMedia(query);
    setMatches(media.matches);

    const listener = (e: MediaQueryListEvent) => setMatches(e.matches);
    media.addEventListener("change", listener);

    return () => media.removeEventListener("change", listener);
  }, [query]);

  return matches;
}

// Usage in app/page.tsx
"use client";

import { useMediaQuery } from "@/hooks/useMediaQuery";

export default function ResponsivePage() {
  const isMobile = useMediaQuery("(max-width: 768px)");

  return (
    <div>
      <p>Device: {isMobile ? "Mobile" : "Desktop"}</p>
    </div>
  );
}
```

**useWindowSize Hook**
```typescript
// hooks/useWindowSize.ts
"use client";

import { useState, useEffect } from "react";

interface WindowSize {
  width: number;
  height: number;
}

export function useWindowSize(): WindowSize {
  const [size, setSize] = useState<WindowSize>({
    width: 0,
    height: 0,
  });

  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    handleResize();
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return size;
}

// Usage
export default function SizePage() {
  const { width, height } = useWindowSize();

  return (
    <div>
      <p>Width: {width}px</p>
      <p>Height: {height}px</p>
    </div>
  );
}
```

**useMounted Hook** (Prevent SSR hydration issues)
```typescript
// hooks/useMounted.ts
"use client";

import { useState, useEffect } from "react";

export function useMounted() {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  return mounted;
}

// Usage
export default function ClientOnlyComponent() {
  const mounted = useMounted();

  if (!mounted) return null;

  return <div>Client-side only content</div>;
}
```

**Key Points:**
- Custom hooks must start with "use"
- Can use other hooks inside
- Return values, not JSX
- Great for reusing logic across components

---

## 8. Generics

### Concept
Generics create reusable, type-safe code that works with multiple types.

### Think: Placeholder for types that get filled in later

### Basic Generic Function

```typescript
// Without generics - need separate functions
function getFirstNumber(arr: number[]): number {
  return arr[0];
}

function getFirstString(arr: string[]): string {
  return arr[0];
}

// With generics - one function for all types
function getFirst<T>(arr: T[]): T {
  return arr[0];
}

// Usage
const num = getFirst([1, 2, 3]); // Type: number
const str = getFirst(["a", "b"]); // Type: string
```

### React Implementation

**Generic List Component**
```typescript
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
}

function List<T>({ items, renderItem }: ListProps<T>) {
  return (
    <div>
      {items.map((item, index) => (
        <div key={index}>{renderItem(item)}</div>
      ))}
    </div>
  );
}

// Usage
interface User {
  id: number;
  name: string;
}

const users: User[] = [
  { id: 1, name: "John" },
  { id: 2, name: "Jane" },
];

<List items={users} renderItem={(user) => <p>{user.name}</p>} />
```

**Generic Data Fetcher**
```typescript
import { useState, useEffect } from "react";

function useFetch<T>(url: string) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(data => {
        setData(data);
        setLoading(false);
      });
  }, [url]);

  return { data, loading };
}

// Usage with different types
interface Post {
  id: number;
  title: string;
}

interface User {
  id: number;
  name: string;
}

const PostsList = () => {
  const { data, loading } = useFetch<Post[]>("/api/posts");
  
  if (loading) return <p>Loading...</p>;
  
  return (
    <div>
      {data?.map(post => <p key={post.id}>{post.title}</p>)}
    </div>
  );
};

const UsersList = () => {
  const { data, loading } = useFetch<User[]>("/api/users");
  
  return (
    <div>
      {data?.map(user => <p key={user.id}>{user.name}</p>)}
    </div>
  );
};
```

**Generic Response Wrapper**
```typescript
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

async function apiCall<T>(endpoint: string): Promise<ApiResponse<T>> {
  const res = await fetch(endpoint);
  const data = await res.json();
  return {
    data,
    status: res.status,
    message: "Success",
  };
}

// Usage
interface Todo {
  id: number;
  title: string;
  completed: boolean;
}

const getTodo = async () => {
  const response = await apiCall<Todo>("/api/todos/1");
  console.log(response.data.title); // Fully typed!
};
```

### Next.js Implementation

**app/list/page.tsx**
```typescript
"use client";

interface DataTableProps<T> {
  data: T[];
  columns: {
    key: keyof T;
    header: string;
  }[];
}

function DataTable<T>({ data, columns }: DataTableProps<T>) {
  return (
    <table style={{ borderCollapse: 'collapse', width: '100%' }}>
      <thead>
        <tr>
          {columns.map(col => (
            <th key={String(col.key)} style={{ border: '1px solid #ddd', padding: '8px' }}>
              {col.header}
            </th>
          ))}
        </tr>
      </thead>
      <tbody>
        {data.map((row, i) => (
          <tr key={i}>
            {columns.map(col => (
              <td key={String(col.key)} style={{ border: '1px solid #ddd', padding: '8px' }}>
                {String(row[col.key])}
              </td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
}

// Usage
export default function TablePage() {
  const products = [
    { id: 1, name: "Laptop", price: 999 },
    { id: 2, name: "Phone", price: 599 },
  ];

  return (
    <DataTable
      data={products}
      columns={[
        { key: "id", header: "ID" },
        { key: "name", header: "Product" },
        { key: "price", header: "Price" },
      ]}
    />
  );
}
```

**Generic Form Handler**
```typescript
function useForm<T extends Record<string, any>>(initialValues: T) {
  const [values, setValues] = useState<T>(initialValues);

  const handleChange = (field: keyof T, value: any) => {
    setValues(prev => ({ ...prev, [field]: value }));
  };

  return { values, handleChange };
}

// Usage with different form types
interface LoginForm {
  email: string;
  password: string;
}

interface SignupForm {
  username: string;
  email: string;
  password: string;
  confirmPassword: string;
}

const Login = () => {
  const { values, handleChange } = useForm<LoginForm>({
    email: "",
    password: "",
  });

  return (
    <div>
      <input
        value={values.email}
        onChange={(e) => handleChange("email", e.target.value)}
      />
      <input
        value={values.password}
        onChange={(e) => handleChange("password", e.target.value)}
      />
    </div>
  );
};
```

**Key Points:**
- Use `<T>` for generic type parameter
- T can be any letter (T, K, V common)
- Makes code reusable across different types
- TypeScript infers types automatically

---

## 9. Utility Types (Exclude)

### Concept
`Exclude<Type, ExcludedUnion>` removes specific types from a union type.

### Syntax
```typescript
type Result = Exclude<UnionType, TypeToRemove>;
```

### Basic Examples

```typescript
type AllColors = "red" | "blue" | "green" | "yellow";

// Remove one
type Primary = Exclude<AllColors, "green">;
// Result: "red" | "blue" | "yellow"

// Remove multiple
type Warm = Exclude<AllColors, "blue" | "green">;
// Result: "red" | "yellow"
```

### React Implementation

**Shape Types**
```typescript
type ShapeType = "cube" | "square" | "rectangle" | "triangle";
type TwoDShapeType = Exclude<ShapeType, "cube">;
// Result: "square" | "rectangle" | "triangle"

interface ShapeProps {
  shape: TwoDShapeType;
}

const ShapeComponent = ({ shape }: ShapeProps) => {
  // Can only be 2D shapes
  return <div>Shape: {shape}</div>;
};

// Usage
<ShapeComponent shape="square" />  // ✅ OK
// <ShapeComponent shape="cube" />  // ❌ Error
```

**Theme Combinations**
```typescript
type Theme = "dark" | "light";
type Color = "red" | "blue" | "yellow";

// All combinations
type ThemeColor = `${Theme}-${Color}`;
// Result: "dark-red" | "dark-blue" | "dark-yellow" | "light-red" | "light-blue" | "light-yellow"

// Exclude specific combinations
type AllowedThemeColors = Exclude<ThemeColor, "dark-yellow" | "light-red">;
// Result: "dark-red" | "dark-blue" | "light-blue" | "light-yellow"

interface ThemedButtonProps {
  color: AllowedThemeColors;
}

const ThemedButton = ({ color }: ThemedButtonProps) => {
  return <button style={{ background: color }}>Button</button>;
};
```

**User Roles**
```typescript
type UserRole = "admin" | "moderator" | "user" | "guest";

// Regular users only
type RegularUser = Exclude<UserRole, "admin" | "moderator">;
// Result: "user" | "guest"

interface UserProfile {
  name: string;
  role: RegularUser;
}

const createUser = (name: string, role: RegularUser): UserProfile => {
  return { name, role };
};

createUser("John", "user");  // ✅ OK
// createUser("Jane", "admin");  // ❌ Error
```

### Next.js Implementation

**Button Variants**
```typescript
type ButtonVariant = "primary" | "secondary" | "danger" | "success" | "disabled";
type ActiveButtonVariant = Exclude<ButtonVariant, "disabled">;

interface ButtonProps {
  variant: ButtonVariant;
  onClick?: () => void;
}

const Button = ({ variant, onClick }: ButtonProps) => {
  const isDisabled = variant === "disabled";

  const styles = {
    primary: { background: "#007bff", color: "white" },
    secondary: { background: "#6c757d", color: "white" },
    danger: { background: "#dc3545", color: "white" },
    success: { background: "#28a745", color: "white" },
    disabled: { background: "#ccc", color: "#666" },
  };

  return (
    <button
      onClick={isDisabled ? undefined : onClick}
      disabled={isDisabled}
      style={{ ...styles[variant], padding: "8px 16px", border: "none", borderRadius: "4px" }}
    >
      {variant}
    </button>
  );
};

export default Button;
```

**HTTP Status Types**
```typescript
type HttpStatus = 200 | 201 | 400 | 401 | 403 | 404 | 500;

type SuccessStatus = Exclude<HttpStatus, 400 | 401 | 403 | 404 | 500>;
// Result: 200 | 201

type ErrorStatus = Exclude<HttpStatus, 200 | 201>;
// Result: 400 | 401 | 403 | 404 | 500

interface ApiResponse<T> {
  data: T;
  status: HttpStatus;
}

const handleSuccess = (status: SuccessStatus) => {
  console.log("Success:", status);
};

const handleError = (status: ErrorStatus) => {
  console.log("Error:", status);
};
```

**Form Field Types**
```typescript
type FormFieldType = "text" | "email" | "password" | "number" | "file" | "hidden";

// Visible fields
type VisibleFieldType = Exclude<FormFieldType, "hidden">;

// Text-based fields
type TextFieldType = Exclude<FormFieldType, "file" | "hidden">;

interface FormFieldProps {
  name: string;
  type: VisibleFieldType;
  label: string;
}

const FormField = ({ name, type, label }: FormFieldProps) => {
  return (
    <div>
      <label>{label}</label>
      <input type={type} name={name} />
    </div>
  );
};
```

**Event Types**
```typescript
type MouseEvents = "click" | "dblclick" | "mousedown" | "mouseup";
type KeyEvents = "keydown" | "keyup" | "keypress";

type ClickEvents = Exclude<MouseEvents, "mousedown" | "mouseup">;
// Result: "click" | "dblclick"

interface ClickHandlerProps {
  eventType: ClickEvents;
  onEvent: () => void;
}

const ClickHandler = ({ eventType, onEvent }: ClickHandlerProps) => {
  return (
    <button onClick={eventType === "click" ? onEvent : undefined}>
      Handle {eventType}
    </button>
  );
};
```

### Comparison with Other Utility Types

```typescript
type All = "a" | "b" | "c" | "d";

// Exclude - removes specified types
type WithoutAB = Exclude<All, "a" | "b">;
// Result: "c" | "d"

// Extract - keeps only specified types
type OnlyAB = Extract<All, "a" | "b">;
// Result: "a" | "b"

// Omit - removes properties from object
type User = { id: number; name: string; password: string };
type PublicUser = Omit<User, "password">;
// Result: { id: number; name: string }

// Pick - keeps only specified properties
type UserCredentials = Pick<User, "name" | "password">;
// Result: { name: string; password: string }
```

**Key Points:**
- Removes types from union types
- Useful for creating subsets of types
- Commonly used with string literal unions
- Opposite of `Extract` utility type

---

## Summary

### Core Concepts

| Concept | Purpose | When to Use |
|---------|---------|-------------|
| **Props** | Pass data from parent to child | Sharing data between components |
| **Children** | Wrap components inside others | Creating layouts and wrappers |
| **Events** | Handle user interactions | Forms, buttons, inputs |
| **useState** | Manage component state | Data that changes and needs re-render |
| **useReducer** | Complex state logic | Multiple related state values |
| **useContext** | Share state globally | Avoid prop drilling |
| **useRef** | Access DOM or store values | Focus, timers, non-reactive values |
| **Custom Hooks** | Reuse stateful logic | Share logic across components |
| **Generics** | Type-safe reusable code | Components/functions with multiple types |
| **Exclude** | Remove types from unions | Creating type subsets |

### Best Practices

1. **Type everything** - Use TypeScript for all props, state, and functions
2. **DRY principle** - Create custom hooks for reusable logic
3. **Component composition** - Use `children` for flexible layouts
4. **Event handling** - Pass function references, not calls
5. **State management** - Use `useState` for simple, `useReducer` for complex
6. **Avoid prop drilling** - Use Context API when needed
7. **Generic components** - Make reusable with generics

### React vs Next.js Key Differences

| Feature | React | Next.js |
|---------|-------|---------|
| **Client Components** | Default | Add `"use client"` |
| **Data Fetching** | useEffect + fetch | Server Components + async/await |
| **Routing** | React Router | File-based routing |
| **Layouts** | Manual | `layout.tsx` files |
| **Hooks** | Works everywhere | Client Components only |

### Quick Syntax Reference

```typescript
// Props
const Component = ({ prop }: { prop: Type }) => <div>{prop}</div>;

// Children
const Layout = ({ children }: { children: React.ReactNode }) => <div>{children}</div>;

// Events
const handleClick = (e: MouseEvent<HTMLButtonElement>) => {};

// useState
const [value, setValue] = useState<Type>(initial);

// useReducer
const [state, dispatch] = useReducer(reducer, initialState);

// useContext
const value = useContext(MyContext);

// useRef
const ref = useRef<HTMLInputElement>(null);

// Custom Hook
const useCustom = () => { /* logic */ return value; };

// Generics
function fn<T>(arg: T): T { return arg; }

// Exclude
type Result = Exclude<"a" | "b" | "c", "a">; // "b" | "c"
```

---

**End of Guide**
