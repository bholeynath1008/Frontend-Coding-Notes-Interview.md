# React, Next.js & TypeScript - Beginner Guide

## Table of Contents
1. [Fetching Data and Passing Props](#1-fetching-data-and-passing-props)
2. [React Children and Component Composition](#2-react-children-and-component-composition)
3. [React Events](#3-react-events)
4. [useState Hook](#4-usestate-hook)
5. [useReducer and useContext](#5-usereducer-and-usecontext)
6. [useRef Hook](#6-useref-hook)
7. [Generics in TypeScript](#7-generics-in-typescript)
8. [TypeScript Utility Types - Exclude](#8-typescript-utility-types---exclude)

---

## 1. Fetching Data and Passing Props

### What is it?
Fetching data from an API and passing it to child components using props (properties).

### Complete Example

**types/types.ts** - Define your data structure
```typescript
export interface PostCardProps {
  id: number;
  title: string;
  body: string;
}
```

**PostList.tsx** - Parent component that fetches data
```typescript
import { useState, useEffect } from "react";
import PostCard from "./PostCard";
import type { PostCardProps } from "../types/types";

const PostList = () => {
  // State to store fetched posts
  const [posts, setPosts] = useState<PostCardProps[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string>("");

  // Function to fetch data
  const getData = async () => {
    try {
      const response = await fetch("https://jsonplaceholder.typicode.com/posts");

      if (!response.ok) {
        throw new Error("Fetching data failed: " + response.status);
      }

      const result = await response.json();
      setPosts(result);
      setLoading(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Unknown error");
      setLoading(false);
    }
  };

  // useEffect runs when component mounts
  useEffect(() => {
    getData();
  }, []); // Empty array means run once on mount

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      <h1>Posts List</h1>
      {posts.map((post) => (
        // Passing data as props to PostCard
        <PostCard 
          key={post.id} 
          id={post.id} 
          title={post.title} 
          body={post.body} 
        />
      ))}
    </div>
  );
};

export default PostList;
```

**PostCard.tsx** - Child component that receives props
```typescript
import type { PostCardProps } from "../types/types";

// Destructuring props directly in parameters
const PostCard = ({ id, title, body }: PostCardProps) => {
  return (
    <div style={{ border: "1px solid #ccc", padding: "10px", margin: "10px" }}>
      <h3>Post #{id}</h3>
      <h4>{title}</h4>
      <p>{body}</p>
    </div>
  );
};

export default PostCard;
```

### Key Concepts
- **Props flow downward**: Data passes from parent to child
- **Type safety**: `PostCardProps` ensures correct data structure
- **Array state**: `useState<PostCardProps[]>([])` stores array of posts
- **map()**: Renders a component for each item in array
- **key prop**: Required for list items, helps React identify changes

---

## 2. React Children and Component Composition

### What is it?
`children` is a special prop that allows you to pass components or elements inside other components. Think of it like nesting HTML elements.

### Why use it?
- Create reusable layout components
- Wrap multiple components with common functionality
- Build flexible, composable UIs

### Complete Example

**CommonLayout.tsx** - Layout wrapper component
```typescript
import type React from "react";

interface LayoutProps {
  children: React.ReactNode;
}

const CommonLayout = ({ children }: LayoutProps) => {
  return (
    <div>
      <header style={{ background: "#333", color: "white", padding: "20px" }}>
        <h1>My App Header</h1>
      </header>
      
      <main style={{ padding: "20px" }}>
        {children} {/* Child components render here */}
      </main>
      
      <footer style={{ background: "#333", color: "white", padding: "20px" }}>
        <p>Footer © 2026</p>
      </footer>
    </div>
  );
};

export default CommonLayout;
```

**Child1.tsx** - Content component
```typescript
const Child1 = () => {
  return (
    <div>
      <h2>Child Component 1</h2>
      <p>This is the content of child 1</p>
    </div>
  );
};

export default Child1;
```

**Child2.tsx** - Another content component
```typescript
const Child2 = () => {
  return (
    <div>
      <h2>Child Component 2</h2>
      <p>This is the content of child 2</p>
    </div>
  );
};

export default Child2;
```

**Page.tsx** - Using the layout
```typescript
import Child1 from "./Child1";
import Child2 from "./Child2";
import CommonLayout from "./CommonLayout";

const Page = () => {
  return (
    <CommonLayout>
      <Child1 />
      <Child2 />
      {/* You can add any content here */}
      <div>
        <p>Additional content goes here</p>
      </div>
    </CommonLayout>
  );
};

export default Page;
```

### Real-World Scenarios

**1. Dashboard Layout**
```typescript
const DashboardLayout = ({ children }: { children: React.ReactNode }) => {
  return (
    <div>
      <nav style={{ width: "200px", float: "left" }}>
        <ul>
          <li>Home</li>
          <li>Profile</li>
          <li>Settings</li>
        </ul>
      </nav>
      <div style={{ marginLeft: "220px" }}>
        {children}
      </div>
    </div>
  );
};

// Usage
<DashboardLayout>
  <UserProfile />
</DashboardLayout>
```

**2. Modal/Dialog Component**
```typescript
const Modal = ({ 
  children, 
  isOpen 
}: { 
  children: React.ReactNode; 
  isOpen: boolean 
}) => {
  if (!isOpen) return null;
  
  return (
    <div style={{ 
      position: "fixed", 
      top: "50%", 
      left: "50%", 
      transform: "translate(-50%, -50%)",
      background: "white",
      padding: "20px"
    }}>
      {children}
    </div>
  );
};

// Usage
<Modal isOpen={true}>
  <h2>Confirm Action</h2>
  <p>Are you sure?</p>
  <button>Yes</button>
  <button>No</button>
</Modal>
```

**3. Card Component**
```typescript
const Card = ({ children }: { children: React.ReactNode }) => {
  return (
    <div style={{ 
      border: "1px solid #ddd", 
      borderRadius: "8px", 
      padding: "16px" 
    }}>
      {children}
    </div>
  );
};

// Usage
<Card>
  <h3>Product Name</h3>
  <p>Product description</p>
  <button>Buy Now</button>
</Card>
```

### React vs Next.js
Both React and Next.js use `children` the same way. The only difference is in Next.js App Router, you can use it for layouts:

**Next.js App Router Layout**
```typescript
// app/layout.tsx
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <nav>Navigation</nav>
        {children}
      </body>
    </html>
  );
}
```

---

## 3. React Events

### What are Events?
Events are actions that happen in the browser (clicks, typing, hovering, etc.). React handles them using event handlers.

### Complete Example - Form with Events

**FormExample.tsx**
```typescript
import { useState, ChangeEvent, MouseEvent, FormEvent } from "react";

const FormExample = () => {
  const [username, setUsername] = useState<string>("");
  const [email, setEmail] = useState<string>("");
  const [message, setMessage] = useState<string>("");

  // Handle input change
  // ChangeEvent<HTMLInputElement> is the type for input changes
  const handleUsernameChange = (event: ChangeEvent<HTMLInputElement>) => {
    setUsername(event.target.value);
  };

  // Inline event handler
  const handleEmailChange = (event: ChangeEvent<HTMLInputElement>) => {
    setEmail(event.target.value);
  };

  // Handle textarea change
  const handleMessageChange = (event: ChangeEvent<HTMLTextAreaElement>) => {
    setMessage(event.target.value);
  };

  // Handle button click
  // MouseEvent<HTMLButtonElement> is the type for button clicks
  const handleButtonClick = (event: MouseEvent<HTMLButtonElement>) => {
    event.preventDefault();
    alert(`Username: ${username}\nEmail: ${email}\nMessage: ${message}`);
  };

  // Handle form submit
  const handleFormSubmit = (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    console.log("Form submitted:", { username, email, message });
  };

  return (
    <div>
      <h2>Contact Form</h2>
      
      <form onSubmit={handleFormSubmit}>
        {/* Input with onChange */}
        <div>
          <label>Username:</label>
          <input
            type="text"
            value={username}
            onChange={handleUsernameChange}
            placeholder="Enter username"
          />
        </div>

        {/* Input with inline handler */}
        <div>
          <label>Email:</label>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            placeholder="Enter email"
          />
        </div>

        {/* Textarea */}
        <div>
          <label>Message:</label>
          <textarea
            value={message}
            onChange={handleMessageChange}
            placeholder="Enter message"
            rows={4}
          />
        </div>

        {/* Button with onClick */}
        <button type="button" onClick={handleButtonClick}>
          Preview
        </button>

        {/* Submit button */}
        <button type="submit">
          Submit Form
        </button>
      </form>

      {/* Display values */}
      <div>
        <h3>Current Values:</h3>
        <p>Username: {username}</p>
        <p>Email: {email}</p>
        <p>Message: {message}</p>
      </div>
    </div>
  );
};

export default FormExample;
```

### Common Event Types

```typescript
import { 
  ChangeEvent, 
  MouseEvent, 
  FormEvent, 
  KeyboardEvent,
  FocusEvent 
} from "react";

const EventTypes = () => {
  // Input change
  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    console.log(e.target.value);
  };

  // Button click
  const handleClick = (e: MouseEvent<HTMLButtonElement>) => {
    console.log("Button clicked");
  };

  // Form submit
  const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    console.log("Form submitted");
  };

  // Key press
  const handleKeyPress = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      console.log("Enter pressed");
    }
  };

  // Focus events
  const handleFocus = (e: FocusEvent<HTMLInputElement>) => {
    console.log("Input focused");
  };

  const handleBlur = (e: FocusEvent<HTMLInputElement>) => {
    console.log("Input lost focus");
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        onChange={handleChange}
        onKeyPress={handleKeyPress}
        onFocus={handleFocus}
        onBlur={handleBlur}
      />
      <button onClick={handleClick}>Click Me</button>
    </form>
  );
};
```

### Important Rules

**❌ WRONG - Calling function immediately**
```typescript
// This calls the function immediately, not on click
<button onClick={handleClick()}>Click</button>
```

**✅ CORRECT - Passing function reference**
```typescript
// This passes the function to be called on click
<button onClick={handleClick}>Click</button>

// Or with inline arrow function
<button onClick={() => handleClick()}>Click</button>

// Passing arguments
<button onClick={() => handleDelete(id)}>Delete</button>
```

---

## 4. useState Hook

### What is useState?
`useState` is a hook that lets you add state (data that can change) to functional components.

### Syntax
```typescript
const [value, setValue] = useState<Type>(initialValue);
```

### Complete Examples

**Example 1: Simple Counter**
```typescript
import { useState } from "react";

const Counter = () => {
  const [count, setCount] = useState<number>(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
};
```

**Example 2: Object State**
```typescript
import { useState } from "react";

interface UserType {
  name: string;
  age: number;
  email: string;
}

const UserForm = () => {
  // State can be null initially
  const [user, setUser] = useState<UserType | null>(null);

  const createUser = () => {
    setUser({
      name: "John Doe",
      age: 30,
      email: "john@example.com"
    });
  };

  const updateName = (newName: string) => {
    if (user) {
      // Spread operator to update one property
      setUser({ ...user, name: newName });
    }
  };

  return (
    <div>
      {user ? (
        <div>
          <p>Name: {user.name}</p>
          <p>Age: {user.age}</p>
          <p>Email: {user.email}</p>
          <button onClick={() => updateName("Jane Doe")}>
            Change Name
          </button>
          <button onClick={() => setUser(null)}>Clear</button>
        </div>
      ) : (
        <button onClick={createUser}>Create User</button>
      )}
    </div>
  );
};
```

**Example 3: Array State**
```typescript
import { useState } from "react";

interface PostProps {
  id: number;
  title: string;
  body: string;
}

const PostManager = () => {
  const [posts, setPosts] = useState<PostProps[]>([]);

  const addPost = () => {
    const newPost: PostProps = {
      id: Date.now(),
      title: "New Post",
      body: "Post content"
    };
    // Add to array
    setPosts([...posts, newPost]);
  };

  const deletePost = (id: number) => {
    // Filter out the post
    setPosts(posts.filter(post => post.id !== id));
  };

  const updatePost = (id: number, newTitle: string) => {
    // Map and update
    setPosts(posts.map(post => 
      post.id === id ? { ...post, title: newTitle } : post
    ));
  };

  return (
    <div>
      <button onClick={addPost}>Add Post</button>
      {posts.map(post => (
        <div key={post.id}>
          <h3>{post.title}</h3>
          <p>{post.body}</p>
          <button onClick={() => updatePost(post.id, "Updated Title")}>
            Update
          </button>
          <button onClick={() => deletePost(post.id)}>
            Delete
          </button>
        </div>
      ))}
    </div>
  );
};
```

**Example 4: Boolean State (Toggle)**
```typescript
const ToggleExample = () => {
  const [isVisible, setIsVisible] = useState<boolean>(false);

  return (
    <div>
      <button onClick={() => setIsVisible(!isVisible)}>
        {isVisible ? "Hide" : "Show"}
      </button>
      {isVisible && <p>This content is visible!</p>}
    </div>
  );
};
```

---

## 5. useReducer and useContext

### What is useReducer?
`useReducer` is an alternative to `useState` for managing complex state logic. It's similar to Redux.

### What is useContext?
`useContext` lets you share state across components without passing props down manually (prop drilling).

### Complete Example: Theme Management

**types.ts** - Define types
```typescript
export type StateType = {
  theme: string;
  fontSize: number;
};

export type ActionType =
  | { type: "CHANGE_THEME"; payload: string }
  | { type: "CHANGE_FONTSIZE"; payload: number }
  | { type: "RESET" };
```

**ThemeContext.tsx** - Create Context and Provider
```typescript
import { createContext, useReducer } from "react";
import type { StateType, ActionType } from "./types";

// Initial state
const INITIAL_STATE: StateType = {
  theme: "dark",
  fontSize: 16,
};

// Reducer function
const reducer = (state: StateType, action: ActionType): StateType => {
  switch (action.type) {
    case "CHANGE_THEME":
      return {
        ...state,
        theme: action.payload,
      };
    case "CHANGE_FONTSIZE":
      return {
        ...state,
        fontSize: action.payload,
      };
    case "RESET":
      return INITIAL_STATE;
    default:
      return state;
  }
};

// Create context with proper type
export const ThemeContext = createContext<{
  state: StateType;
  dispatch: React.Dispatch<ActionType>;
}>({
  state: INITIAL_STATE,
  dispatch: () => {},
});

// Provider component
export const ThemeProvider = ({ children }: { children: React.ReactNode }) => {
  const [state, dispatch] = useReducer(reducer, INITIAL_STATE);

  return (
    <ThemeContext.Provider value={{ state, dispatch }}>
      {children}
    </ThemeContext.Provider>
  );
};
```

**App.tsx** - Wrap app with provider
```typescript
import { ThemeProvider } from "./ThemeContext";
import ThemeControls from "./ThemeControls";
import Content from "./Content";

const App = () => {
  return (
    <ThemeProvider>
      <div>
        <h1>Theme App</h1>
        <ThemeControls />
        <Content />
      </div>
    </ThemeProvider>
  );
};

export default App;
```

**ThemeControls.tsx** - Component that updates context
```typescript
import { useContext } from "react";
import { ThemeContext } from "./ThemeContext";

const ThemeControls = () => {
  const { state, dispatch } = useContext(ThemeContext);

  return (
    <div>
      <h2>Theme Controls</h2>
      
      <div>
        <button
          onClick={() => dispatch({ type: "CHANGE_THEME", payload: "dark" })}
        >
          Dark Theme
        </button>
        <button
          onClick={() => dispatch({ type: "CHANGE_THEME", payload: "light" })}
        >
          Light Theme
        </button>
      </div>

      <div>
        <button
          onClick={() => dispatch({ type: "CHANGE_FONTSIZE", payload: 14 })}
        >
          Small Font
        </button>
        <button
          onClick={() => dispatch({ type: "CHANGE_FONTSIZE", payload: 16 })}
        >
          Medium Font
        </button>
        <button
          onClick={() => dispatch({ type: "CHANGE_FONTSIZE", payload: 20 })}
        >
          Large Font
        </button>
      </div>

      <button onClick={() => dispatch({ type: "RESET" })}>
        Reset to Default
      </button>

      <p>Current Theme: {state.theme}</p>
      <p>Current Font Size: {state.fontSize}px</p>
    </div>
  );
};

export default ThemeControls;
```

**Content.tsx** - Component that uses context
```typescript
import { useContext } from "react";
import { ThemeContext } from "./ThemeContext";

const Content = () => {
  const { state } = useContext(ThemeContext);

  const contentStyle = {
    background: state.theme === "dark" ? "#333" : "#fff",
    color: state.theme === "dark" ? "#fff" : "#333",
    fontSize: `${state.fontSize}px`,
    padding: "20px",
    marginTop: "20px",
  };

  return (
    <div style={contentStyle}>
      <h2>Content Area</h2>
      <p>This text adapts to the theme and font size from context.</p>
      <p>Current theme: {state.theme}</p>
      <p>Current font size: {state.fontSize}px</p>
    </div>
  );
};

export default Content;
```

### Another Example: Todo App with useReducer

```typescript
import { useReducer, useState } from "react";

interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

type Action =
  | { type: "ADD_TODO"; payload: string }
  | { type: "TOGGLE_TODO"; payload: number }
  | { type: "DELETE_TODO"; payload: number };

const todoReducer = (state: Todo[], action: Action): Todo[] => {
  switch (action.type) {
    case "ADD_TODO":
      return [
        ...state,
        { id: Date.now(), text: action.payload, completed: false },
      ];
    case "TOGGLE_TODO":
      return state.map((todo) =>
        todo.id === action.payload
          ? { ...todo, completed: !todo.completed }
          : todo
      );
    case "DELETE_TODO":
      return state.filter((todo) => todo.id !== action.payload);
    default:
      return state;
  }
};

const TodoApp = () => {
  const [todos, dispatch] = useReducer(todoReducer, []);
  const [input, setInput] = useState("");

  const handleAdd = () => {
    if (input.trim()) {
      dispatch({ type: "ADD_TODO", payload: input });
      setInput("");
    }
  };

  return (
    <div>
      <h2>Todo List</h2>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Add todo"
      />
      <button onClick={handleAdd}>Add</button>

      <ul>
        {todos.map((todo) => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => dispatch({ type: "TOGGLE_TODO", payload: todo.id })}
            />
            <span
              style={{
                textDecoration: todo.completed ? "line-through" : "none",
              }}
            >
              {todo.text}
            </span>
            <button onClick={() => dispatch({ type: "DELETE_TODO", payload: todo.id })}>
              Delete
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
};
```

---

## 6. useRef Hook

### What is useRef?
`useRef` creates a reference to a DOM element or stores a mutable value that persists across renders without causing re-renders.

### Common Use Cases
1. Accessing DOM elements directly
2. Storing previous values
3. Storing timers/intervals
4. Focus management

### Complete Examples

**Example 1: Focus Input on Button Click**
```typescript
import { useRef } from "react";

const FocusInput = () => {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleFocus = () => {
    // Access the DOM element and focus it
    inputRef.current?.focus();
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Click button to focus me" />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
};

export default FocusInput;
```

**Example 2: Auto-focus on Mount (Next.js)**
```typescript
"use client";

import { useRef, useEffect } from "react";

const AutoFocusExample = () => {
  const inputRef = useRef<HTMLInputElement>(null);
  const usernameInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    // Focus the input when component mounts
    inputRef.current?.focus();
  }, []);

  const handleSubmit = () => {
    // Access input values without state
    console.log("Input value:", inputRef.current?.value);
    console.log("Username:", usernameInputRef.current?.value);
  };

  return (
    <div>
      <h2>Auto Focus Example</h2>
      <input ref={inputRef} type="text" placeholder="Auto-focused on load" />
      <input ref={usernameInputRef} type="text" placeholder="Username" />
      <button onClick={handleSubmit}>Submit</button>
    </div>
  );
};

export default AutoFocusExample;
```

**Example 3: Storing Previous Value**
```typescript
import { useState, useRef, useEffect } from "react";

const PreviousValue = () => {
  const [count, setCount] = useState(0);
  const previousCountRef = useRef<number>();

  useEffect(() => {
    // Store the current value after each render
    previousCountRef.current = count;
  }, [count]);

  return (
    <div>
      <p>Current Count: {count}</p>
      <p>Previous Count: {previousCountRef.current}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

**Example 4: Timer with useRef**
```typescript
import { useState, useRef } from "react";

const Timer = () => {
  const [seconds, setSeconds] = useState(0);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const startTimer = () => {
    if (intervalRef.current) return; // Already running

    intervalRef.current = setInterval(() => {
      setSeconds((prev) => prev + 1);
    }, 1000);
  };

  const stopTimer = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };

  const resetTimer = () => {
    stopTimer();
    setSeconds(0);
  };

  return (
    <div>
      <h2>Timer: {seconds}s</h2>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
      <button onClick={resetTimer}>Reset</button>
    </div>
  );
};
```

**Example 5: Video Player Control**
```typescript
import { useRef } from "react";

const VideoPlayer = () => {
  const videoRef = useRef<HTMLVideoElement>(null);

  const playVideo = () => {
    videoRef.current?.play();
  };

  const pauseVideo = () => {
    videoRef.current?.pause();
  };

  const restartVideo = () => {
    if (videoRef.current) {
      videoRef.current.currentTime = 0;
      videoRef.current.play();
    }
  };

  return (
    <div>
      <video ref={videoRef} width="400">
        <source src="video.mp4" type="video/mp4" />
      </video>
      <div>
        <button onClick={playVideo}>Play</button>
        <button onClick={pauseVideo}>Pause</button>
        <button onClick={restartVideo}>Restart</button>
      </div>
    </div>
  );
};
```

### useRef vs useState

```typescript
const RefVsState = () => {
  const [stateCount, setStateCount] = useState(0);
  const refCount = useRef(0);

  const incrementState = () => {
    setStateCount(stateCount + 1); // Causes re-render
  };

  const incrementRef = () => {
    refCount.current = refCount.current + 1; // No re-render
    console.log("Ref count:", refCount.current);
  };

  return (
    <div>
      <p>State Count (causes re-render): {stateCount}</p>
      <p>Ref Count (check console, no re-render): {refCount.current}</p>
      <button onClick={incrementState}>Increment State</button>
      <button onClick={incrementRef}>Increment Ref</button>
    </div>
  );
};
```

---

## 7. Generics in TypeScript

### What are Generics?
Generics allow you to write reusable code that works with multiple types while maintaining type safety.

### Think of it as: A placeholder for a type that gets filled in later.

### Complete Examples

**Example 1: Generic Function**
```typescript
// Without generics - need separate functions for each type
function getFirstNumber(arr: number[]): number {
  return arr[0];
}

function getFirstString(arr: string[]): string {
  return arr[0];
}

// With generics - one function for all types
function getFirst<T>(arr: T[]): T {
  return arr[0];
}

// Usage
const firstNum = getFirst<number>([1, 2, 3]); // Type: number
const firstStr = getFirst<string>(["a", "b", "c"]); // Type: string
const firstBool = getFirst<boolean>([true, false]); // Type: boolean

// TypeScript can infer the type
const firstAuto = getFirst([1, 2, 3]); // Type: number (inferred)
```

**Example 2: Generic React Component**
```typescript
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
}

function List<T>({ items, renderItem }: ListProps<T>) {
  return (
    <div>
      {items.map((item, index) => (
        <div key={index}>{renderItem(item)}</div>
      ))}
    </div>
  );
}

// Usage with different types
interface User {
  id: number;
  name: string;
}

interface Product {
  id: number;
  title: string;
  price: number;
}

const UsersAndProducts = () => {
  const users: User[] = [
    { id: 1, name: "John" },
    { id: 2, name: "Jane" },
  ];

  const products: Product[] = [
    { id: 1, title: "Laptop", price: 999 },
    { id: 2, title: "Phone", price: 599 },
  ];

  return (
    <div>
      <h2>Users</h2>
      <List
        items={users}
        renderItem={(user) => <p>{user.name}</p>}
      />

      <h2>Products</h2>
      <List
        items={products}
        renderItem={(product) => (
          <p>
            {product.title} - ${product.price}
          </p>
        )}
      />
    </div>
  );
};
```

**Example 3: Generic Data Fetcher (React)**
```typescript
import { useState, useEffect } from "react";

interface FetchState<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
}

function useFetch<T>(url: string): FetchState<T> {
  const [state, setState] = useState<FetchState<T>>({
    data: null,
    loading: true,
    error: null,
  });

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error("Fetch failed");
        const data: T = await response.json();
        setState({ data, loading: false, error: null });
      } catch (err) {
        setState({
          data: null,
          loading: false,
          error: err instanceof Error ? err.message : "Unknown error",
        });
      }
    };

    fetchData();
  }, [url]);

  return state;
}

// Usage with different data types
interface Post {
  id: number;
  title: string;
  body: string;
}

interface User {
  id: number;
  name: string;
  email: string;
}

const DataFetchingExample = () => {
  const posts = useFetch<Post[]>("https://jsonplaceholder.typicode.com/posts");
  const users = useFetch<User[]>("https://jsonplaceholder.typicode.com/users");

  return (
    <div>
      <h2>Posts</h2>
      {posts.loading && <p>Loading posts...</p>}
      {posts.error && <p>Error: {posts.error}</p>}
      {posts.data?.slice(0, 3).map((post) => (
        <div key={post.id}>
          <h3>{post.title}</h3>
          <p>{post.body}</p>
        </div>
      ))}

      <h2>Users</h2>
      {users.loading && <p>Loading users...</p>}
      {users.error && <p>Error: {users.error}</p>}
      {users.data?.slice(0, 3).map((user) => (
        <div key={user.id}>
          <p>{user.name} - {user.email}</p>
        </div>
      ))}
    </div>
  );
};
```

**Example 4: Generic API Response (Next.js)**
```typescript
"use client";

import { useState } from "react";

interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

async function apiRequest<T>(endpoint: string): Promise<ApiResponse<T>> {
  const response = await fetch(endpoint);
  const data = await response.json();
  return {
    data,
    status: response.status,
    message: "Success",
  };
}

interface Todo {
  id: number;
  title: string;
  completed: boolean;
}

const ApiExample = () => {
  const [todo, setTodo] = useState<Todo | null>(null);

  const loadTodo = async () => {
    const response = await apiRequest<Todo>(
      "https://jsonplaceholder.typicode.com/todos/1"
    );
    setTodo(response.data);
  };

  return (
    <div>
      <button onClick={loadTodo}>Load Todo</button>
      {todo && (
        <div>
          <p>ID: {todo.id}</p>
          <p>Title: {todo.title}</p>
          <p>Completed: {todo.completed ? "Yes" : "No"}</p>
        </div>
      )}
    </div>
  );
};
```

**Example 5: Generic Form Handler**
```typescript
import { useState, ChangeEvent } from "react";

function useForm<T>(initialValues: T) {
  const [values, setValues] = useState<T>(initialValues);

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setValues({
      ...values,
      [name]: value,
    });
  };

  const reset = () => {
    setValues(initialValues);
  };

  return { values, handleChange, reset };
}

// Usage
interface LoginForm {
  email: string;
  password: string;
}

interface SignupForm {
  username: string;
  email: string;
  password: string;
  confirmPassword: string;
}

const FormExample = () => {
  const login = useForm<LoginForm>({
    email: "",
    password: "",
  });

  const signup = useForm<SignupForm>({
    username: "",
    email: "",
    password: "",
    confirmPassword: "",
  });

  return (
    <div>
      <h2>Login Form</h2>
      <input
        name="email"
        value={login.values.email}
        onChange={login.handleChange}
        placeholder="Email"
      />
      <input
        name="password"
        value={login.values.password}
        onChange={login.handleChange}
        placeholder="Password"
        type="password"
      />
      <button onClick={login.reset}>Reset</button>

      <h2>Signup Form</h2>
      <input
        name="username"
        value={signup.values.username}
        onChange={signup.handleChange}
        placeholder="Username"
      />
      <input
        name="email"
        value={signup.values.email}
        onChange={signup.handleChange}
        placeholder="Email"
      />
      <button onClick={signup.reset}>Reset</button>
    </div>
  );
};
```

---

## 8. TypeScript Utility Types - Exclude

### What is Exclude?
`Exclude<Type, ExcludedUnion>` removes types from a union type.

### Syntax
```typescript
type Result = Exclude<Type, TypeToRemove>;
```

### Complete Examples

**Example 1: Basic Exclude**
```typescript
type AllColors = "red" | "blue" | "green" | "yellow";

// Remove one color
type PrimaryColors = Exclude<AllColors, "green">;
// Result: "red" | "blue" | "yellow"

// Remove multiple colors
type WarmColors = Exclude<AllColors, "blue" | "green">;
// Result: "red" | "yellow"

const color1: PrimaryColors = "red"; // ✅ OK
const color2: PrimaryColors = "blue"; // ✅ OK
// const color3: PrimaryColors = "green"; // ❌ Error
```

**Example 2: Shape Example (From Your Document)**
```typescript
type ShapeType = "cube" | "square" | "rectangle" | "triangle";

// Exclude 3D shapes to get only 2D shapes
type TwoDShapeType = Exclude<ShapeType, "cube">;
// Result: "square" | "rectangle" | "triangle"

interface ShapeProps {
  shape: ShapeType;
  twoDShape: TwoDShapeType;
}

const Shape = (props: ShapeProps) => {
  const shape: ShapeType = "cube"; // ✅ OK
  const twoDShape: TwoDShapeType = "square"; // ✅ OK
  // const twoDShape2: TwoDShapeType = "cube"; // ❌ Error

  return (
    <div>
      <p>Shape: {shape}</p>
      <p>2D Shape: {twoDShape}</p>
    </div>
  );
};

export default Shape;
```

**Example 3: Theme Color Combinations**
```typescript
type ThemeType = "dark" | "light";
type ColorType = "red" | "blue" | "yellow";

// Create all possible combinations
type ThemeColorType = `${ThemeType}-${ColorType}`;
// Result: "dark-red" | "dark-blue" | "dark-yellow" | "light-red" | "light-blue" | "light-yellow"

// Exclude specific combinations
type AllowedThemeColors = Exclude<
  ThemeColorType,
  "dark-yellow" | "light-red"
>;
// Result: "dark-red" | "dark-blue" | "light-blue" | "light-yellow"

const validColor: AllowedThemeColors = "dark-red"; // ✅ OK
// const invalidColor: AllowedThemeColors = "dark-yellow"; // ❌ Error
```

**Example 4: User Roles**
```typescript
type UserRole = "admin" | "moderator" | "user" | "guest";

// Regular users (exclude admin roles)
type RegularUser = Exclude<UserRole, "admin" | "moderator">;
// Result: "user" | "guest"

interface User {
  name: string;
  role: UserRole;
}

interface RegularUserProfile {
  name: string;
  role: RegularUser;
}

const checkAccess = (user: User) => {
  // Type narrowing with Exclude
  if (user.role === "admin" || user.role === "moderator") {
    console.log("Has special access");
  } else {
    // Here, user.role is automatically: RegularUser
    const regularRole: RegularUser = user.role;
    console.log("Regular user:", regularRole);
  }
};
```

**Example 5: Event Types**
```typescript
type MouseEvents = "click" | "dblclick" | "mousedown" | "mouseup" | "mousemove";
type KeyboardEvents = "keydown" | "keyup" | "keypress";

type AllEvents = MouseEvents | KeyboardEvents;

// Only click events
type ClickEvents = Exclude<MouseEvents, "mousedown" | "mouseup" | "mousemove">;
// Result: "click" | "dblclick"

// Non-click events
type NonClickEvents = Exclude<MouseEvents, ClickEvents>;
// Result: "mousedown" | "mouseup" | "mousemove"

const handleEvent = (eventType: ClickEvents) => {
  console.log("Click event:", eventType);
};

handleEvent("click"); // ✅ OK
// handleEvent("mousedown"); // ❌ Error
```

**Example 6: API Response Status**
```typescript
type HttpStatus = 200 | 201 | 400 | 401 | 403 | 404 | 500;

// Success statuses
type SuccessStatus = Exclude<HttpStatus, 400 | 401 | 403 | 404 | 500>;
// Result: 200 | 201

// Error statuses
type ErrorStatus = Exclude<HttpStatus, 200 | 201>;
// Result: 400 | 401 | 403 | 404 | 500

interface ApiResponse<T> {
  data: T;
  status: HttpStatus;
}

const handleSuccess = (status: SuccessStatus) => {
  if (status === 200) {
    console.log("OK");
  } else if (status === 201) {
    console.log("Created");
  }
};

const handleError = (status: ErrorStatus) => {
  console.log("Error status:", status);
};
```

**Example 7: React Component Props**
```typescript
import { useState } from "react";

type ButtonVariant = "primary" | "secondary" | "danger" | "success" | "disabled";

// Active buttons (exclude disabled)
type ActiveButtonVariant = Exclude<ButtonVariant, "disabled">;

interface ButtonProps {
  variant: ButtonVariant;
  onClick?: () => void;
}

const Button = ({ variant, onClick }: ButtonProps) => {
  const isDisabled = variant === "disabled";

  const handleClick = () => {
    if (!isDisabled && onClick) {
      onClick();
    }
  };

  return (
    <button
      onClick={handleClick}
      disabled={isDisabled}
      style={{
        padding: "10px 20px",
        opacity: isDisabled ? 0.5 : 1,
        cursor: isDisabled ? "not-allowed" : "pointer",
      }}
    >
      {variant} Button
    </button>
  );
};

const ButtonDemo = () => {
  const [activeVariant, setActiveVariant] = useState<ActiveButtonVariant>("primary");

  return (
    <div>
      <Button variant="primary" onClick={() => console.log("Primary clicked")} />
      <Button variant="secondary" onClick={() => console.log("Secondary clicked")} />
      <Button variant="disabled" />

      <p>Current active variant: {activeVariant}</p>
    </div>
  );
};
```

**Example 8: Form Field Types**
```typescript
type FormFieldType = "text" | "email" | "password" | "number" | "file" | "hidden";

// Visible fields
type VisibleFieldType = Exclude<FormFieldType, "hidden">;

// Text-based fields
type TextBasedFieldType = Exclude<FormFieldType, "file" | "hidden">;

interface FormField {
  name: string;
  type: FormFieldType;
  label?: string;
}

interface VisibleFormField {
  name: string;
  type: VisibleFieldType;
  label: string; // Required for visible fields
}

const renderField = (field: VisibleFormField) => {
  return (
    <div>
      <label>{field.label}</label>
      <input type={field.type} name={field.name} />
    </div>
  );
};

const FormExample = () => {
  const visibleFields: VisibleFormField[] = [
    { name: "username", type: "text", label: "Username" },
    { name: "email", type: "email", label: "Email" },
    { name: "age", type: "number", label: "Age" },
  ];

  return (
    <form>
      {visibleFields.map((field) => (
        <div key={field.name}>{renderField(field)}</div>
      ))}
    </form>
  );
};
```

### Exclude vs Other Utility Types

```typescript
// Exclude - removes types from union
type A = Exclude<"a" | "b" | "c", "a">;
// Result: "b" | "c"

// Extract - keeps only specified types
type B = Extract<"a" | "b" | "c", "a" | "d">;
// Result: "a"

// Omit - removes properties from object
type User = { id: number; name: string; password: string };
type PublicUser = Omit<User, "password">;
// Result: { id: number; name: string }

// Pick - keeps only specified properties
type UserCredentials = Pick<User, "name" | "password">;
// Result: { name: string; password: string }
```

---

## Summary

### Key Takeaways

1. **Props & Data Flow**: Data flows down from parent to child components
2. **Children**: Special prop for component composition and layouts
3. **Events**: Handle user interactions with typed event handlers
4. **useState**: Manage component state that causes re-renders
5. **useReducer + useContext**: Manage complex state across multiple components
6. **useRef**: Access DOM elements and store values without re-renders
7. **Generics**: Write reusable, type-safe code
8. **Exclude**: Remove specific types from unions

### Best Practices

- Always type your props and state
- Use `children` for reusable layouts
- Don't call functions in event handlers (pass reference)
- Use `useReducer` for complex state logic
- Use `useRef` for DOM access and non-reactive values
- Use generics for reusable components
- Use `Exclude` to constrain type unions

### Next.js Specific Notes

- Use `"use client"` directive for client components
- `useEffect`, `useState`, and other hooks require client components
- Server components are default in App Router
- Both React and Next.js share the same TypeScript patterns

---

## Quick Reference

```typescript
// Props
interface Props {
  name: string;
}
const Component = ({ name }: Props) => <div>{name}</div>;

// Children
const Layout = ({ children }: { children: React.ReactNode }) => <div>{children}</div>;

// Events
const handleClick = (e: MouseEvent<HTMLButtonElement>) => {};
const handleChange = (e: ChangeEvent<HTMLInputElement>) => {};

// useState
const [value, setValue] = useState<Type>(initial);

// useReducer
const [state, dispatch] = useReducer(reducer, initialState);

// useContext
const value = useContext(MyContext);

// useRef
const ref = useRef<HTMLInputElement>(null);

// Generics
function fn<T>(arg: T): T { return arg; }

// Exclude
type Result = Exclude<"a" | "b" | "c", "a">; // "b" | "c"
```
